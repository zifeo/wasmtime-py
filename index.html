<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>wasmtime API documentation</title>
<meta name="description" content="Python bindings for the [Wasmtime project] …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>wasmtime</code></h1>
</header>
<section id="section-intro">
<p>Python bindings for the <a href="https://github.com/bytecodealliance/wasmtime">Wasmtime project</a></p>
<p>This library binds the <a href="https://github.com/bytecodealliance/wasmtime">Wasmtime project</a>'s C API to provide an implementation
of a WebAssembly JIT compiler to Python. You can validate, compile, instantiate,
and interact with WebAssembly modules via this library.</p>
<p>The API of this library is intended to be very similar to the <a href="https://docs.rs/wasmtime"><code>wasmtime</code> Rust
crate</a>, so if you find the docs are lacking here feel
free to consult that documentation as well. While not exactly the same the two
libraries are intended to be quite similar.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Python bindings for the [Wasmtime project]

[Wasmtime project]: https://github.com/bytecodealliance/wasmtime

This library binds the [Wasmtime project]&#39;s C API to provide an implementation
of a WebAssembly JIT compiler to Python. You can validate, compile, instantiate,
and interact with WebAssembly modules via this library.

The API of this library is intended to be very similar to the [`wasmtime` Rust
crate](https://docs.rs/wasmtime), so if you find the docs are lacking here feel
free to consult that documentation as well. While not exactly the same the two
libraries are intended to be quite similar.
&#34;&#34;&#34;

from ._error import WasmtimeError, ExitTrap
from ._config import Config
from ._engine import Engine
from ._store import Store, Storelike
from ._types import FuncType, GlobalType, MemoryType, TableType
from ._types import ValType, Limits, ImportType, ExportType
from ._wat2wasm import wat2wasm
from ._module import Module
from ._value import Val, IntoVal
from ._trap import Trap, Frame, TrapCode
from ._func import Func, Caller
from ._globals import Global
from ._table import Table
from ._memory import Memory
from ._instance import Instance
from ._wasi import WasiConfig
from ._linker import Linker

__all__ = [
    &#39;wat2wasm&#39;,
    &#39;Config&#39;,
    &#39;Engine&#39;,
    &#39;Store&#39;,
    &#39;FuncType&#39;,
    &#39;GlobalType&#39;,
    &#39;MemoryType&#39;,
    &#39;TableType&#39;,
    &#39;ValType&#39;,
    &#39;Limits&#39;,
    &#39;ImportType&#39;,
    &#39;ExportType&#39;,
    &#39;IntoVal&#39;,
    &#39;Val&#39;,
    &#39;Func&#39;,
    &#39;Caller&#39;,
    &#39;Table&#39;,
    &#39;Memory&#39;,
    &#39;Global&#39;,
    &#39;Trap&#39;,
    &#39;TrapCode&#39;,
    &#39;ExitTrap&#39;,
    &#39;Frame&#39;,
    &#39;Module&#39;,
    &#39;Instance&#39;,
    &#39;WasiConfig&#39;,
    &#39;Linker&#39;,
    &#39;WasmtimeError&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="wasmtime.bindgen" href="bindgen/index.html">wasmtime.bindgen</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="wasmtime.loader" href="loader.html">wasmtime.loader</a></code></dt>
<dd>
<div class="desc"><p>This module is a custom loader for Python which enables importing wasm files
directly into Python programs simply through usage of the <code>import</code> …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wasmtime.wat2wasm"><code class="name flex">
<span>def <span class="ident">wat2wasm</span></span>(<span>wat: Union[str, bytes]) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the <a href="https://webassembly.github.io/spec/core/text/index.html">WebAssembly Text format</a> to the binary format.</p>
<p>This function is intended to be a convenience function for local
development and you likely don't want to use it extensively in production.
It's much faster to parse and compile the binary format than it is to
process the text format.</p>
<p>Takes a <code>str</code> as input, raises an error if it fails to parse, and returns
a <code>bytes</code> if conversion/parsing was successful.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; wat2wasm('(module)')
bytearray(b'\x00asm\x01\x00\x00\x00')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wat2wasm(wat: typing.Union[str, bytes]) -&gt; bytearray:
    &#34;&#34;&#34;
    Converts the [WebAssembly Text format][wat] to the binary format.

    This function is intended to be a convenience function for local
    development and you likely don&#39;t want to use it extensively in production.
    It&#39;s much faster to parse and compile the binary format than it is to
    process the text format.

    Takes a `str` as input, raises an error if it fails to parse, and returns
    a `bytes` if conversion/parsing was successful.

    &gt;&gt;&gt; wat2wasm(&#39;(module)&#39;)
    bytearray(b&#39;\\x00asm\\x01\\x00\\x00\\x00&#39;)

    [wat]: https://webassembly.github.io/spec/core/text/index.html
    &#34;&#34;&#34;

    if isinstance(wat, str):
        wat = wat.encode(&#39;utf8&#39;)
    wat_buffer = create_string_buffer(wat)
    wasm = ffi.wasm_byte_vec_t()
    error = ffi.wasmtime_wat2wasm(wat_buffer, len(wat), byref(wasm))
    if error:
        raise WasmtimeError._from_ptr(error)
    else:
        ret = ffi.to_bytes(wasm)
        ffi.wasm_byte_vec_delete(byref(wasm))
        return ret</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wasmtime.Caller"><code class="flex name class">
<span>class <span class="ident">Caller</span></span>
<span>(</span><span>ptr: ctypes._Pointer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Caller:
    _context: &#34;ctypes._Pointer[ffi.wasmtime_context_t]&#34;

    def __init__(self, ptr: &#34;ctypes._Pointer&#34;):
        self._ptr = ptr

    def __getitem__(self, name: str) -&gt; AsExtern:
        &#34;&#34;&#34;
        Looks up an export with `name` on the calling module.

        If `name` isn&#39;t defined on the calling module, or if the caller has gone
        away for some reason, then this will raise a `KeyError`. For more
        information about when this could fail see the `get` method which
        returns `None` on failure.
        &#34;&#34;&#34;

        ret = self.get(name)
        if ret is None:
            raise KeyError(&#34;failed to find export {}&#34;.format(name))
        return ret

    def get(self, name: str) -&gt; Optional[AsExtern]:
        &#34;&#34;&#34;
        Looks up an export with `name` on the calling module.

        May return `None` if the export isn&#39;t found, if it&#39;s not a memory (for
        now), or if the caller has gone away and this `Caller` object has
        persisted too long.
        &#34;&#34;&#34;

        # First convert to a raw name so we can typecheck our argument
        name_bytes = name.encode(&#39;utf-8&#39;)
        name_buf = ffi.create_string_buffer(name_bytes)

        # Next see if we&#39;ve been invalidated
        if not hasattr(self, &#39;_ptr&#39;):
            return None

        # And if we&#39;re not invalidated we can perform the actual lookup
        item = ffi.wasmtime_extern_t()
        ok = ffi.wasmtime_caller_export_get(self._ptr, name_buf, len(name_bytes), byref(item))
        if ok:
            return wrap_extern(item)
        else:
            return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Caller.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name: str) ‑> Union[<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>, <a title="wasmtime.Table" href="#wasmtime.Table">Table</a>, <a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>, <a title="wasmtime.Global" href="#wasmtime.Global">Global</a>, <a title="wasmtime.Instance" href="#wasmtime.Instance">Instance</a>, <a title="wasmtime.Module" href="#wasmtime.Module">Module</a>, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up an export with <code>name</code> on the calling module.</p>
<p>May return <code>None</code> if the export isn't found, if it's not a memory (for
now), or if the caller has gone away and this <code><a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a></code> object has
persisted too long.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name: str) -&gt; Optional[AsExtern]:
    &#34;&#34;&#34;
    Looks up an export with `name` on the calling module.

    May return `None` if the export isn&#39;t found, if it&#39;s not a memory (for
    now), or if the caller has gone away and this `Caller` object has
    persisted too long.
    &#34;&#34;&#34;

    # First convert to a raw name so we can typecheck our argument
    name_bytes = name.encode(&#39;utf-8&#39;)
    name_buf = ffi.create_string_buffer(name_bytes)

    # Next see if we&#39;ve been invalidated
    if not hasattr(self, &#39;_ptr&#39;):
        return None

    # And if we&#39;re not invalidated we can perform the actual lookup
    item = ffi.wasmtime_extern_t()
    ok = ffi.wasmtime_caller_export_get(self._ptr, name_buf, len(name_bytes), byref(item))
    if ok:
        return wrap_extern(item)
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
</code></dt>
<dd>
<div class="desc"><p>Global configuration, used to create an <code><a title="wasmtime.Engine" href="#wasmtime.Engine">Engine</a></code>.</p>
<p>A <code><a title="wasmtime.Config" href="#wasmtime.Config">Config</a></code> houses a number of configuration options which tweaks how wasm
code is compiled or generated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config:
    &#34;&#34;&#34;
    Global configuration, used to create an `Engine`.

    A `Config` houses a number of configuration options which tweaks how wasm
    code is compiled or generated.
    &#34;&#34;&#34;

    _ptr: &#34;ctypes._Pointer[ffi.wasm_config_t]&#34;

    def __init__(self) -&gt; None:
        self._ptr = ffi.wasm_config_new()

    @setter_property
    def debug_info(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether DWARF debug information is emitted for the generated
        code. This can improve profiling and the debugging experience.
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_debug_info_set(self._ptr, enable)

    @setter_property
    def wasm_threads(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [threads proposal] is enabled.

        [threads proposal]: https://github.com/webassembly/threads
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_threads_set(self._ptr, enable)

    @setter_property
    def wasm_reference_types(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [reference types proposal] is enabled.

        [reference types proposal]: https://github.com/webassembly/reference-types
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_reference_types_set(self._ptr, enable)

    @setter_property
    def wasm_simd(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [SIMD proposal] is enabled.

        [SIMD proposal]: https://github.com/webassembly/simd
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_simd_set(self._ptr, enable)

    @setter_property
    def wasm_bulk_memory(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [bulk memory proposal] is enabled.

        [bulk memory proposal]: https://github.com/webassembly/bulk-memory
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_bulk_memory_set(self._ptr, enable)

    @setter_property
    def wasm_multi_value(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [multi value proposal] is enabled.

        [multi value proposal]: https://github.com/webassembly/multi-value
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_multi_value_set(self._ptr, enable)

    @setter_property
    def wasm_multi_memory(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [multi memory proposal] is enabled.

        [multi memory proposal]: https://github.com/webassembly/multi-memory
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_multi_memory_set(self._ptr, enable)

    @setter_property
    def wasm_memory64(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [memory64 proposal] is enabled.

        [memory64 proposal]: https://github.com/webassembly/memory64
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_memory64_set(self._ptr, enable)

    @setter_property
    def strategy(self, strategy: str) -&gt; None:
        &#34;&#34;&#34;
        Configures the compilation strategy used for wasm code.

        Acceptable values for `strategy` are:

        * `&#34;auto&#34;`
        * `&#34;cranelift&#34;`
        &#34;&#34;&#34;

        if strategy == &#34;auto&#34;:
            ffi.wasmtime_config_strategy_set(self._ptr, 0)
        elif strategy == &#34;cranelift&#34;:
            ffi.wasmtime_config_strategy_set(self._ptr, 1)
        else:
            raise WasmtimeError(&#34;unknown strategy: &#34; + str(strategy))

    @setter_property
    def cranelift_debug_verifier(self, enable: bool) -&gt; None:
        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_cranelift_debug_verifier_set(self._ptr, enable)

    @setter_property
    def cranelift_opt_level(self, opt_level: str) -&gt; None:
        if opt_level == &#34;none&#34;:
            ffi.wasmtime_config_cranelift_opt_level_set(self._ptr, 0)
        elif opt_level == &#34;speed&#34;:
            ffi.wasmtime_config_cranelift_opt_level_set(self._ptr, 1)
        elif opt_level == &#34;speed_and_size&#34;:
            ffi.wasmtime_config_cranelift_opt_level_set(self._ptr, 2)
        else:
            raise WasmtimeError(&#34;unknown opt level: &#34; + str(opt_level))

    @setter_property
    def profiler(self, profiler: str) -&gt; None:
        if profiler == &#34;none&#34;:
            ffi.wasmtime_config_profiler_set(self._ptr, 0)
        elif profiler == &#34;jitdump&#34;:
            ffi.wasmtime_config_profiler_set(self._ptr, 1)
        else:
            raise WasmtimeError(&#34;unknown profiler: &#34; + str(profiler))

    @setter_property
    def cache(self, enabled: typing.Union[bool, str]) -&gt; None:
        &#34;&#34;&#34;
        Configures whether code caching is enabled for this `Config`.

        The value `True` can be passed in here to enable the default caching
        configuration and location, or a path to a file can be passed in which
        is a path to a TOML configuration file for the cache.

        More information about cache configuration can be found at
        https://bytecodealliance.github.io/wasmtime/cli-cache.html
        &#34;&#34;&#34;

        if isinstance(enabled, bool):
            if not enabled:
                raise WasmtimeError(&#34;caching cannot be explicitly disabled&#34;)
            error = ffi.wasmtime_config_cache_config_load(self._ptr, None)
        elif isinstance(enabled, str):
            error = ffi.wasmtime_config_cache_config_load(self._ptr,
                                                          c_char_p(enabled.encode(&#39;utf-8&#39;)))
        else:
            raise TypeError(&#34;expected string or bool&#34;)
        if error:
            raise WasmtimeError._from_ptr(error)

    @setter_property
    def epoch_interruption(self, enabled: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether wasm execution can be interrupted via epoch
        increments.
        &#34;&#34;&#34;

        if enabled:
            val = 1
        else:
            val = 0
        ffi.wasmtime_config_epoch_interruption_set(self._ptr, val)

    @setter_property
    def consume_fuel(self, instances: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether wasm code will consume *fuel* as part of its
        execution.

        Fuel consumption allows WebAssembly to trap when fuel runs out.
        Currently stores start with 0 fuel if this is enabled.
        &#34;&#34;&#34;
        if not isinstance(instances, bool):
            raise TypeError(&#39;expected an bool&#39;)
        ffi.wasmtime_config_consume_fuel_set(self._ptr, instances)

    @setter_property
    def parallel_compilation(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether parallel compilation is enabled for functions
        within a module.

        This is enabled by default.
        &#34;&#34;&#34;
        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_parallel_compilation_set(self._ptr, enable)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_config_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Config.cache"><code class="name">var <span class="ident">cache</span></code></dt>
<dd>
<div class="desc"><p>Configures whether code caching is enabled for this <code><a title="wasmtime.Config" href="#wasmtime.Config">Config</a></code>.</p>
<p>The value <code>True</code> can be passed in here to enable the default caching
configuration and location, or a path to a file can be passed in which
is a path to a TOML configuration file for the cache.</p>
<p>More information about cache configuration can be found at
<a href="https://bytecodealliance.github.io/wasmtime/cli-cache.html">https://bytecodealliance.github.io/wasmtime/cli-cache.html</a></p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.consume_fuel"><code class="name">var <span class="ident">consume_fuel</span></code></dt>
<dd>
<div class="desc"><p>Configures whether wasm code will consume <em>fuel</em> as part of its
execution.</p>
<p>Fuel consumption allows WebAssembly to trap when fuel runs out.
Currently stores start with 0 fuel if this is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.cranelift_debug_verifier"><code class="name">var <span class="ident">cranelift_debug_verifier</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.Config.cranelift_opt_level"><code class="name">var <span class="ident">cranelift_opt_level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.Config.debug_info"><code class="name">var <span class="ident">debug_info</span></code></dt>
<dd>
<div class="desc"><p>Configures whether DWARF debug information is emitted for the generated
code. This can improve profiling and the debugging experience.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.epoch_interruption"><code class="name">var <span class="ident">epoch_interruption</span></code></dt>
<dd>
<div class="desc"><p>Configures whether wasm execution can be interrupted via epoch
increments.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.parallel_compilation"><code class="name">var <span class="ident">parallel_compilation</span></code></dt>
<dd>
<div class="desc"><p>Configures whether parallel compilation is enabled for functions
within a module.</p>
<p>This is enabled by default.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.profiler"><code class="name">var <span class="ident">profiler</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.Config.strategy"><code class="name">var <span class="ident">strategy</span></code></dt>
<dd>
<div class="desc"><p>Configures the compilation strategy used for wasm code.</p>
<p>Acceptable values for <code>strategy</code> are:</p>
<ul>
<li><code>"auto"</code></li>
<li><code>"cranelift"</code></li>
</ul>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_bulk_memory"><code class="name">var <span class="ident">wasm_bulk_memory</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/bulk-memory">bulk memory proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_memory64"><code class="name">var <span class="ident">wasm_memory64</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/memory64">memory64 proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_multi_memory"><code class="name">var <span class="ident">wasm_multi_memory</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/multi-memory">multi memory proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_multi_value"><code class="name">var <span class="ident">wasm_multi_value</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/multi-value">multi value proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_reference_types"><code class="name">var <span class="ident">wasm_reference_types</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/reference-types">reference types proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_simd"><code class="name">var <span class="ident">wasm_simd</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/simd">SIMD proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_threads"><code class="name">var <span class="ident">wasm_threads</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/threads">threads proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
</dl>
</dd>
<dt id="wasmtime.Engine"><code class="flex name class">
<span>class <span class="ident">Engine</span></span>
<span>(</span><span>config: Optional[wasmtime._config.Config] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Engine:
    _ptr: &#34;ctypes._Pointer[ffi.wasm_engine_t]&#34;

    def __init__(self, config: Optional[Config] = None):
        if config is None:
            self._ptr = ffi.wasm_engine_new()
        elif not isinstance(config, Config):
            raise TypeError(&#34;expected Config&#34;)
        elif not hasattr(config, &#39;_ptr&#39;):
            raise WasmtimeError(&#34;Config already used&#34;)
        else:
            ptr = config._ptr
            delattr(config, &#39;_ptr&#39;)
            self._ptr = ffi.wasm_engine_new_with_config(ptr)

    def increment_epoch(self) -&gt; None:
        ffi.wasmtime_engine_increment_epoch(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_engine_delete(self._ptr)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Engine.increment_epoch"><code class="name flex">
<span>def <span class="ident">increment_epoch</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_epoch(self) -&gt; None:
    ffi.wasmtime_engine_increment_epoch(self._ptr)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.ExitTrap"><code class="flex name class">
<span>class <span class="ident">ExitTrap</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A special type of <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> which represents the process exiting via
WASI's <code>proc_exit</code> function call.</p>
<p>Whenever a WASI program exits via <code>proc_exit</code> a trap is raised, but the
trap will have this type instead of <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code>, so you can catch just
this type instead of all traps (if desired). Exit traps have a <code>code</code>
associated with them which is the exit code provided at exit.</p>
<p>Note that <code><a title="wasmtime.ExitTrap" href="#wasmtime.ExitTrap">ExitTrap</a></code> is a subclass of <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code>, so if you catch a
trap you'll also catch <code><a title="wasmtime.ExitTrap" href="#wasmtime.ExitTrap">ExitTrap</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExitTrap(WasmtimeError):
    &#34;&#34;&#34;
    A special type of `WasmtimeError` which represents the process exiting via
    WASI&#39;s `proc_exit` function call.

    Whenever a WASI program exits via `proc_exit` a trap is raised, but the
    trap will have this type instead of `WasmtimeError`, so you can catch just
    this type instead of all traps (if desired). Exit traps have a `code`
    associated with them which is the exit code provided at exit.

    Note that `ExitTrap` is a subclass of `WasmtimeError`, so if you catch a
    trap you&#39;ll also catch `ExitTrap`.
    &#34;&#34;&#34;
    code: int
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>wasmtime._error.WasmtimeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="wasmtime.ExitTrap.code"><code class="name">var <span class="ident">code</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="wasmtime.ExportType"><code class="flex name class">
<span>class <span class="ident">ExportType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExportType:
    _ptr: &#34;ctypes._Pointer[ffi.wasm_exporttype_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def _from_ptr(cls, ptr: &#39;ctypes._Pointer[ffi.wasm_exporttype_t]&#39;, owner: Optional[Any]) -&gt; &#34;ExportType&#34;:
        ty: &#34;ExportType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_exporttype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the name in the modulethis export type refers to
        &#34;&#34;&#34;
        return ffi.to_str(ffi.wasm_exporttype_name(self._ptr).contents)

    @property
    def type(self) -&gt; &#34;AsExternType&#34;:
        &#34;&#34;&#34;
        Returns the type that this export refers to
        &#34;&#34;&#34;
        ptr = ffi.wasm_exporttype_type(self._ptr)
        return wrap_externtype(ptr, self._owner or self)

    def __del__(self) -&gt; None:
        if self._owner is None:
            ffi.wasm_exporttype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.ExportType.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the name in the modulethis export type refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the name in the modulethis export type refers to
    &#34;&#34;&#34;
    return ffi.to_str(ffi.wasm_exporttype_name(self._ptr).contents)</code></pre>
</details>
</dd>
<dt id="wasmtime.ExportType.type"><code class="name">var <span class="ident">type</span> : Union[wasmtime._types.FuncType, wasmtime._types.TableType, wasmtime._types.MemoryType, wasmtime._types.GlobalType]</code></dt>
<dd>
<div class="desc"><p>Returns the type that this export refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; &#34;AsExternType&#34;:
    &#34;&#34;&#34;
    Returns the type that this export refers to
    &#34;&#34;&#34;
    ptr = ffi.wasm_exporttype_type(self._ptr)
    return wrap_externtype(ptr, self._owner or self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame:
    _ptr: &#34;ctypes._Pointer[ffi.wasm_frame_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasm_frame_t]&#34;, owner: Optional[Any]) -&gt; &#34;Frame&#34;:
        ty: &#34;Frame&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_frame_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def func_index(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the function index this frame corresponds to in its wasm module
        &#34;&#34;&#34;

        return ffi.wasm_frame_func_index(self._ptr)

    @property
    def func_name(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the name of the function this frame corresponds to

        May return `None` if no name can be inferred
        &#34;&#34;&#34;

        ptr = ffi.wasmtime_frame_func_name(self._ptr)
        if ptr:
            return ffi.to_str(ptr.contents)
        else:
            return None

    @property
    def module_name(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the name of the module this frame corresponds to

        May return `None` if no name can be inferred
        &#34;&#34;&#34;

        ptr = ffi.wasmtime_frame_module_name(self._ptr)
        if ptr:
            return ffi.to_str(ptr.contents)
        else:
            return None

    @property
    def module_offset(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the offset of this frame&#39;s program counter into the original
        wasm source module.
        &#34;&#34;&#34;

        return ffi.wasm_frame_module_offset(self._ptr)

    @property
    def func_offset(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the offset of this frame&#39;s program counter into the original
        wasm function.
        &#34;&#34;&#34;

        return ffi.wasm_frame_func_offset(self._ptr)

    def __del__(self) -&gt; None:
        if self._owner is None:
            ffi.wasm_frame_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Frame.func_index"><code class="name">var <span class="ident">func_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the function index this frame corresponds to in its wasm module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def func_index(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the function index this frame corresponds to in its wasm module
    &#34;&#34;&#34;

    return ffi.wasm_frame_func_index(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.func_name"><code class="name">var <span class="ident">func_name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Returns the name of the function this frame corresponds to</p>
<p>May return <code>None</code> if no name can be inferred</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def func_name(self) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the name of the function this frame corresponds to

    May return `None` if no name can be inferred
    &#34;&#34;&#34;

    ptr = ffi.wasmtime_frame_func_name(self._ptr)
    if ptr:
        return ffi.to_str(ptr.contents)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.func_offset"><code class="name">var <span class="ident">func_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the offset of this frame's program counter into the original
wasm function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def func_offset(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the offset of this frame&#39;s program counter into the original
    wasm function.
    &#34;&#34;&#34;

    return ffi.wasm_frame_func_offset(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.module_name"><code class="name">var <span class="ident">module_name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Returns the name of the module this frame corresponds to</p>
<p>May return <code>None</code> if no name can be inferred</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def module_name(self) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the name of the module this frame corresponds to

    May return `None` if no name can be inferred
    &#34;&#34;&#34;

    ptr = ffi.wasmtime_frame_module_name(self._ptr)
    if ptr:
        return ffi.to_str(ptr.contents)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.module_offset"><code class="name">var <span class="ident">module_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the offset of this frame's program counter into the original
wasm source module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def module_offset(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the offset of this frame&#39;s program counter into the original
    wasm source module.
    &#34;&#34;&#34;

    return ffi.wasm_frame_module_offset(self._ptr)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Func"><code class="flex name class">
<span>class <span class="ident">Func</span></span>
<span>(</span><span>store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], ty: wasmtime._types.FuncType, func: Callable, access_caller: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new func in <code>store</code> with the given <code>ty</code> which calls the closure
given</p>
<p>The <code>func</code> is called with the parameters natively and they'll have native
Python values rather than being wrapped in <code><a title="wasmtime.Val" href="#wasmtime.Val">Val</a></code>. If <code>access_caller</code> is
set to <code>True</code> then the first argument given to <code>func</code> is an instance of
type <code><a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a></code> below.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Func:
    _func: ffi.wasmtime_func_t

    def __init__(self, store: Storelike, ty: FuncType, func: Callable, access_caller: bool = False):
        &#34;&#34;&#34;
        Creates a new func in `store` with the given `ty` which calls the closure
        given

        The `func` is called with the parameters natively and they&#39;ll have native
        Python values rather than being wrapped in `Val`. If `access_caller` is
        set to `True` then the first argument given to `func` is an instance of
        type `Caller` below.
        &#34;&#34;&#34;

        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        if not isinstance(ty, FuncType):
            raise TypeError(&#34;expected a FuncType&#34;)
        idx = FUNCTIONS.allocate((func, ty.results, access_caller))
        _func = ffi.wasmtime_func_t()
        ffi.wasmtime_func_new(
            store._context,
            ty._ptr,
            trampoline,
            idx,
            finalize,
            byref(_func))
        self._func = _func

    @classmethod
    def _from_raw(cls, func: ffi.wasmtime_func_t) -&gt; &#34;Func&#34;:
        ty: &#34;Func&#34; = cls.__new__(cls)
        ty._func = func
        return ty

    def type(self, store: Storelike) -&gt; FuncType:
        &#34;&#34;&#34;
        Gets the type of this func as a `FuncType`
        &#34;&#34;&#34;
        ptr = ffi.wasmtime_func_type(store._context, byref(self._func))
        return FuncType._from_ptr(ptr, None)

    def __call__(self, store: Storelike, *params: IntoVal) -&gt; Union[IntoVal, Sequence[IntoVal], None]:
        &#34;&#34;&#34;
        Calls this function with the given parameters

        Parameters can either be a `Val` or a native python value which can be
        converted to a `Val` of the corresponding correct type

        Returns `None` if this func has 0 return types
        Returns a single value if the func has 1 return type
        Returns a list if the func has more than 1 return type

        Note that you can also use the `__call__` method and invoke a `Func` as
        if it were a function directly.
        &#34;&#34;&#34;

        ty = self.type(store)
        param_tys = ty.params
        if len(params) &gt; len(param_tys):
            raise WasmtimeError(&#34;too many parameters provided: given %s, expected %s&#34; %
                                (len(params), len(param_tys)))
        if len(params) &lt; len(param_tys):
            raise WasmtimeError(&#34;too few parameters provided: given %s, expected %s&#34; %
                                (len(params), len(param_tys)))

        param_vals = [Val._convert(ty, params[i]) for i, ty in enumerate(param_tys)]
        params_ptr = (ffi.wasmtime_val_t * len(params))()
        for i, val in enumerate(param_vals):
            params_ptr[i] = val._unwrap_raw()

        result_tys = ty.results
        results_ptr = (ffi.wasmtime_val_t * len(result_tys))()

        with enter_wasm(store) as trap:
            error = ffi.wasmtime_func_call(
                store._context,
                byref(self._func),
                params_ptr,
                len(params),
                results_ptr,
                len(result_tys),
                trap)
            if error:
                raise WasmtimeError._from_ptr(error)

        results = []
        for i in range(0, len(result_tys)):
            results.append(Val(results_ptr[i]).value)
        if len(results) == 0:
            return None
        elif len(results) == 1:
            return results[0]
        else:
            return results

    def _as_extern(self) -&gt; ffi.wasmtime_extern_t:
        union = ffi.wasmtime_extern_union(func=self._func)
        return ffi.wasmtime_extern_t(ffi.WASMTIME_EXTERN_FUNC, union)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Func.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> wasmtime._types.FuncType</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the type of this func as a <code><a title="wasmtime.FuncType" href="#wasmtime.FuncType">FuncType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(self, store: Storelike) -&gt; FuncType:
    &#34;&#34;&#34;
    Gets the type of this func as a `FuncType`
    &#34;&#34;&#34;
    ptr = ffi.wasmtime_func_type(store._context, byref(self._func))
    return FuncType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.FuncType"><code class="flex name class">
<span>class <span class="ident">FuncType</span></span>
<span>(</span><span>params: List[wasmtime._types.ValType], results: List[wasmtime._types.ValType])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncType:
    def __init__(self, params: List[ValType], results: List[ValType]):
        for param in params:
            if not isinstance(param, ValType):
                raise TypeError(&#34;expected ValType&#34;)
        for result in results:
            if not isinstance(result, ValType):
                raise TypeError(&#34;expected ValType&#34;)

        params_ffi = ffi.wasm_valtype_vec_t()
        ffi.wasm_valtype_vec_new_uninitialized(byref(params_ffi), len(params))

        results_ffi = ffi.wasm_valtype_vec_t()
        for i, param in enumerate(params):
            params_ffi.data[i] = take_owned_valtype(param)

        ffi.wasm_valtype_vec_new_uninitialized(
            byref(results_ffi), len(results))
        for i, result in enumerate(results):
            results_ffi.data[i] = take_owned_valtype(result)
        ptr = ffi.wasm_functype_new(byref(params_ffi), byref(results_ffi))
        if not ptr:
            raise WasmtimeError(&#34;failed to allocate FuncType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasm_functype_t]&#34;, owner: Optional[Any]) -&gt; &#34;FuncType&#34;:
        ty: &#34;FuncType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_functype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def params(self) -&gt; List[&#34;ValType&#34;]:
        &#34;&#34;&#34;
        Returns the list of parameter types for this function type
        &#34;&#34;&#34;

        ptr = ffi.wasm_functype_params(self._ptr)
        return ValType._from_list(ptr, self)

    @property
    def results(self) -&gt; List[&#34;ValType&#34;]:
        &#34;&#34;&#34;
        Returns the list of result types for this function type
        &#34;&#34;&#34;

        ptr = ffi.wasm_functype_results(self._ptr)
        return ValType._from_list(ptr, self)

    def _as_extern(self) -&gt; &#34;ctypes._Pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_functype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_functype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.FuncType.params"><code class="name">var <span class="ident">params</span> : List[wasmtime._types.ValType]</code></dt>
<dd>
<div class="desc"><p>Returns the list of parameter types for this function type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self) -&gt; List[&#34;ValType&#34;]:
    &#34;&#34;&#34;
    Returns the list of parameter types for this function type
    &#34;&#34;&#34;

    ptr = ffi.wasm_functype_params(self._ptr)
    return ValType._from_list(ptr, self)</code></pre>
</details>
</dd>
<dt id="wasmtime.FuncType.results"><code class="name">var <span class="ident">results</span> : List[wasmtime._types.ValType]</code></dt>
<dd>
<div class="desc"><p>Returns the list of result types for this function type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def results(self) -&gt; List[&#34;ValType&#34;]:
    &#34;&#34;&#34;
    Returns the list of result types for this function type
    &#34;&#34;&#34;

    ptr = ffi.wasm_functype_results(self._ptr)
    return ValType._from_list(ptr, self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Global"><code class="flex name class">
<span>class <span class="ident">Global</span></span>
<span>(</span><span>store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], ty: wasmtime._types.GlobalType, val: Union[wasmtime._value.Val, int, float, ForwardRef(None), ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Global:
    _global: ffi.wasmtime_global_t

    def __init__(self, store: Storelike, ty: GlobalType, val: IntoVal):
        if not isinstance(ty, GlobalType):
            raise TypeError(&#34;expected a GlobalType&#34;)
        val = Val._convert(ty.content, val)
        global_ = ffi.wasmtime_global_t()
        error = ffi.wasmtime_global_new(
            store._context,
            ty._ptr,
            byref(val._unwrap_raw()),
            byref(global_))
        if error:
            raise WasmtimeError._from_ptr(error)
        self._global = global_

    @classmethod
    def _from_raw(cls, global_: ffi.wasmtime_global_t) -&gt; &#34;Global&#34;:
        ty: &#34;Global&#34; = cls.__new__(cls)
        ty._global = global_
        return ty

    def type(self, store: Storelike) -&gt; GlobalType:
        &#34;&#34;&#34;
        Gets the type of this global as a `GlobalType`
        &#34;&#34;&#34;

        ptr = ffi.wasmtime_global_type(store._context, byref(self._global))
        return GlobalType._from_ptr(ptr, None)

    def value(self, store: Storelike) -&gt; IntoVal:
        &#34;&#34;&#34;
        Gets the current value of this global

        Returns a native python type
        &#34;&#34;&#34;
        raw = ffi.wasmtime_val_t()
        ffi.wasmtime_global_get(store._context, byref(self._global), byref(raw))
        val = Val(raw)
        if val.value is not None:
            return val.value
        else:
            return val

    def set_value(self, store: Storelike, val: IntoVal) -&gt; None:
        &#34;&#34;&#34;
        Sets the value of this global to a new value
        &#34;&#34;&#34;
        val = Val._convert(self.type(store).content, val)
        error = ffi.wasmtime_global_set(store._context, byref(self._global), byref(val._unwrap_raw()))
        if error:
            raise WasmtimeError._from_ptr(error)

    def _as_extern(self) -&gt; ffi.wasmtime_extern_t:
        union = ffi.wasmtime_extern_union(global_=self._global)
        return ffi.wasmtime_extern_t(ffi.WASMTIME_EXTERN_GLOBAL, union)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Global.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], val: Union[wasmtime._value.Val, int, float, ForwardRef(None), ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the value of this global to a new value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, store: Storelike, val: IntoVal) -&gt; None:
    &#34;&#34;&#34;
    Sets the value of this global to a new value
    &#34;&#34;&#34;
    val = Val._convert(self.type(store).content, val)
    error = ffi.wasmtime_global_set(store._context, byref(self._global), byref(val._unwrap_raw()))
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Global.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> wasmtime._types.GlobalType</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the type of this global as a <code><a title="wasmtime.GlobalType" href="#wasmtime.GlobalType">GlobalType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(self, store: Storelike) -&gt; GlobalType:
    &#34;&#34;&#34;
    Gets the type of this global as a `GlobalType`
    &#34;&#34;&#34;

    ptr = ffi.wasmtime_global_type(store._context, byref(self._global))
    return GlobalType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.Global.value"><code class="name flex">
<span>def <span class="ident">value</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> Union[wasmtime._value.Val, int, float, ForwardRef(None), <a title="wasmtime.Func" href="#wasmtime.Func">Func</a>, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the current value of this global</p>
<p>Returns a native python type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def value(self, store: Storelike) -&gt; IntoVal:
    &#34;&#34;&#34;
    Gets the current value of this global

    Returns a native python type
    &#34;&#34;&#34;
    raw = ffi.wasmtime_val_t()
    ffi.wasmtime_global_get(store._context, byref(self._global), byref(raw))
    val = Val(raw)
    if val.value is not None:
        return val.value
    else:
        return val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.GlobalType"><code class="flex name class">
<span>class <span class="ident">GlobalType</span></span>
<span>(</span><span>valtype: wasmtime._types.ValType, mutable: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GlobalType:
    def __init__(self, valtype: ValType, mutable: bool):
        if mutable:
            mutability = ffi.WASM_VAR
        else:
            mutability = ffi.WASM_CONST
        type_ptr = take_owned_valtype(valtype)
        ptr = ffi.wasm_globaltype_new(type_ptr, mutability)
        if ptr == 0:
            raise WasmtimeError(&#34;failed to allocate GlobalType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasm_globaltype_t]&#34;, owner: Optional[Any]) -&gt; &#34;GlobalType&#34;:
        ty: &#34;GlobalType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_globaltype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def content(self) -&gt; ValType:
        &#34;&#34;&#34;
        Returns the type this global contains
        &#34;&#34;&#34;

        ptr = ffi.wasm_globaltype_content(self._ptr)
        return ValType._from_ptr(ptr, self)

    @property
    def mutable(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether this global is mutable or not
        &#34;&#34;&#34;
        val = ffi.wasm_globaltype_mutability(self._ptr)
        return val == ffi.WASM_VAR.value

    def _as_extern(self) -&gt; &#34;ctypes._Pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_globaltype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_globaltype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.GlobalType.content"><code class="name">var <span class="ident">content</span> : wasmtime._types.ValType</code></dt>
<dd>
<div class="desc"><p>Returns the type this global contains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self) -&gt; ValType:
    &#34;&#34;&#34;
    Returns the type this global contains
    &#34;&#34;&#34;

    ptr = ffi.wasm_globaltype_content(self._ptr)
    return ValType._from_ptr(ptr, self)</code></pre>
</details>
</dd>
<dt id="wasmtime.GlobalType.mutable"><code class="name">var <span class="ident">mutable</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns whether this global is mutable or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mutable(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns whether this global is mutable or not
    &#34;&#34;&#34;
    val = ffi.wasm_globaltype_mutability(self._ptr)
    return val == ffi.WASM_VAR.value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.ImportType"><code class="flex name class">
<span>class <span class="ident">ImportType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImportType:
    _ptr: &#34;ctypes._Pointer[ffi.wasm_importtype_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasm_importtype_t]&#34;, owner: Optional[Any]) -&gt; &#34;ImportType&#34;:
        ty: &#34;ImportType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_importtype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def module(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the module this import type refers to
        &#34;&#34;&#34;

        return ffi.to_str(ffi.wasm_importtype_module(self._ptr).contents)

    @property
    def name(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the name in the modulethis import type refers toa.

        Note that `None` may be returned for the module linking proposal where
        the field name is optional.
        &#34;&#34;&#34;
        ptr = ffi.wasm_importtype_name(self._ptr)
        if ptr:
            return ffi.to_str(ptr.contents)
        return None

    @property
    def type(self) -&gt; &#34;AsExternType&#34;:
        &#34;&#34;&#34;
        Returns the type that this import refers to
        &#34;&#34;&#34;
        ptr = ffi.wasm_importtype_type(self._ptr)
        return wrap_externtype(ptr, self._owner or self)

    def __del__(self) -&gt; None:
        if self._owner is None:
            ffi.wasm_importtype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.ImportType.module"><code class="name">var <span class="ident">module</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the module this import type refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def module(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the module this import type refers to
    &#34;&#34;&#34;

    return ffi.to_str(ffi.wasm_importtype_module(self._ptr).contents)</code></pre>
</details>
</dd>
<dt id="wasmtime.ImportType.name"><code class="name">var <span class="ident">name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Returns the name in the modulethis import type refers toa.</p>
<p>Note that <code>None</code> may be returned for the module linking proposal where
the field name is optional.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the name in the modulethis import type refers toa.

    Note that `None` may be returned for the module linking proposal where
    the field name is optional.
    &#34;&#34;&#34;
    ptr = ffi.wasm_importtype_name(self._ptr)
    if ptr:
        return ffi.to_str(ptr.contents)
    return None</code></pre>
</details>
</dd>
<dt id="wasmtime.ImportType.type"><code class="name">var <span class="ident">type</span> : Union[wasmtime._types.FuncType, wasmtime._types.TableType, wasmtime._types.MemoryType, wasmtime._types.GlobalType]</code></dt>
<dd>
<div class="desc"><p>Returns the type that this import refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; &#34;AsExternType&#34;:
    &#34;&#34;&#34;
    Returns the type that this import refers to
    &#34;&#34;&#34;
    ptr = ffi.wasm_importtype_type(self._ptr)
    return wrap_externtype(ptr, self._owner or self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Instance"><code class="flex name class">
<span>class <span class="ident">Instance</span></span>
<span>(</span><span>store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], module: wasmtime._module.Module, imports: Sequence[Union[ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), ForwardRef('<a title="wasmtime.Table" href="#wasmtime.Table">Table</a>'), ForwardRef('<a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>'), ForwardRef('<a title="wasmtime.Global" href="#wasmtime.Global">Global</a>'), ForwardRef('<a title="wasmtime.Instance" href="#wasmtime.Instance">Instance</a>'), ForwardRef('<a title="wasmtime.Module" href="#wasmtime.Module">Module</a>')]])</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new instance by instantiating the <code>module</code> given with the
<code>imports</code> into the <code>store</code> provided.</p>
<p>The <code>store</code> must have type <code><a title="wasmtime.Store" href="#wasmtime.Store">Store</a></code>, the <code>module</code> must have type
<code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code>, and the <code>imports</code> must be an iterable of external values,
either <code>Extern</code>, <code><a title="wasmtime.Func" href="#wasmtime.Func">Func</a></code>, <code><a title="wasmtime.Table" href="#wasmtime.Table">Table</a></code>, <code><a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a></code>, or <code><a title="wasmtime.Global" href="#wasmtime.Global">Global</a></code>.</p>
<p>Raises an error if instantiation fails (e.g. linking or trap) and
otherwise initializes the new instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Instance:
    _instance: ffi.wasmtime_instance_t
    _exports: Optional[&#34;InstanceExports&#34;]

    def __init__(self, store: Storelike, module: Module, imports: Sequence[AsExtern]):
        &#34;&#34;&#34;
        Creates a new instance by instantiating the `module` given with the
        `imports` into the `store` provided.

        The `store` must have type `Store`, the `module` must have type
        `Module`, and the `imports` must be an iterable of external values,
        either `Extern`, `Func`, `Table`, `Memory`, or `Global`.

        Raises an error if instantiation fails (e.g. linking or trap) and
        otherwise initializes the new instance.
        &#34;&#34;&#34;

        imports_ptr = (ffi.wasmtime_extern_t * len(imports))()
        for i, val in enumerate(imports):
            imports_ptr[i] = get_extern_ptr(val)

        instance = ffi.wasmtime_instance_t()
        trap = POINTER(ffi.wasm_trap_t)()
        with enter_wasm(store) as trap:
            error = ffi.wasmtime_instance_new(
                store._context,
                module._ptr,
                imports_ptr,
                len(imports),
                byref(instance),
                trap)
            if error:
                raise WasmtimeError._from_ptr(error)
        self._instance = instance
        self._exports = None

    @classmethod
    def _from_raw(cls, instance: ffi.wasmtime_instance_t) -&gt; &#34;Instance&#34;:
        ty: &#34;Instance&#34; = cls.__new__(cls)
        ty._exports = None
        ty._instance = instance
        return ty

    def exports(self, store: Storelike) -&gt; &#34;InstanceExports&#34;:
        &#34;&#34;&#34;
        Returns the exports of this module

        The returned type can be indexed both with integers and with strings for
        names of exports.
        &#34;&#34;&#34;
        if self._exports is None:
            self._exports = InstanceExports(store, self)
        return self._exports

    def _as_extern(self) -&gt; ffi.wasmtime_extern_t:
        union = ffi.wasmtime_extern_union(instance=self._instance)
        return ffi.wasmtime_extern_t(ffi.WASMTIME_EXTERN_INSTANCE, union)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Instance.exports"><code class="name flex">
<span>def <span class="ident">exports</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> wasmtime._instance.InstanceExports</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the exports of this module</p>
<p>The returned type can be indexed both with integers and with strings for
names of exports.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exports(self, store: Storelike) -&gt; &#34;InstanceExports&#34;:
    &#34;&#34;&#34;
    Returns the exports of this module

    The returned type can be indexed both with integers and with strings for
    names of exports.
    &#34;&#34;&#34;
    if self._exports is None:
        self._exports = InstanceExports(store, self)
    return self._exports</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Limits"><code class="flex name class">
<span>class <span class="ident">Limits</span></span>
<span>(</span><span>min: int, max: Optional[int])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Limits:
    def __init__(self, min: int, max: Optional[int]):
        self.min = min
        self.max = max

    def __ffi__(self) -&gt; ffi.wasm_limits_t:
        max = self.max
        if max is None:
            max = 0xffffffff
        return ffi.wasm_limits_t(self.min, max)

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, Limits):
            return False
        return self.min == other.min and self.max == other.max

    @classmethod
    def _from_ffi(cls, val: &#39;ctypes._Pointer[ffi.wasm_limits_t]&#39;) -&gt; &#34;Limits&#34;:
        min = val.contents.min
        max = val.contents.max
        if max == 0xffffffff:
            return Limits(min, None)
        return Limits(min, max)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker"><code class="flex name class">
<span>class <span class="ident">Linker</span></span>
<span>(</span><span>engine: wasmtime._engine.Engine)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new linker ready to instantiate modules within the store
provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Linker:
    engine: Engine

    def __init__(self, engine: Engine):
        &#34;&#34;&#34;
        Creates a new linker ready to instantiate modules within the store
        provided.
        &#34;&#34;&#34;
        self._ptr = ffi.wasmtime_linker_new(engine._ptr)
        self.engine = engine

    @setter_property
    def allow_shadowing(self, allow: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether definitions are allowed to shadow one another within
        this linker
        &#34;&#34;&#34;
        if not isinstance(allow, bool):
            raise TypeError(&#34;expected a boolean&#34;)
        ffi.wasmtime_linker_allow_shadowing(self._ptr, allow)

    def define(self, store: Storelike, module: str, name: str, item: AsExtern) -&gt; None:
        &#34;&#34;&#34;
        Defines a new item, by name, in this linker.

        This method will add a new definition to this linker. The `module` nad
        `name` provided are what to name the `item` within the linker.

        This function will raise an error if `item` comes from the wrong store
        or if shadowing is disallowed and the module/name pair has already been
        defined.
        &#34;&#34;&#34;
        raw_item = get_extern_ptr(item)
        module_bytes = module.encode(&#39;utf-8&#39;)
        module_buf = create_string_buffer(module_bytes)
        name_bytes = name.encode(&#39;utf-8&#39;)
        name_buf = create_string_buffer(name_bytes)
        error = ffi.wasmtime_linker_define(
            self._ptr,
            store._context,
            module_buf,
            len(module_bytes),
            name_buf,
            len(name_bytes),
            byref(raw_item))
        if error:
            raise WasmtimeError._from_ptr(error)

    def define_func(self, module: str, name: str, ty: FuncType, func: Callable[..., Any], access_caller: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Defines a new function, by name, in this linker.

        This method is similar to `define` except that you can directly define a
        function without creating a `Func` itself. This enables
        `Store`-independent functions to be inserted into this linker, meaning
        the linker can be used to instantiate modules in multiple stores.
        &#34;&#34;&#34;
        module_bytes = module.encode(&#39;utf-8&#39;)
        module_buf = create_string_buffer(module_bytes)
        name_bytes = name.encode(&#39;utf-8&#39;)
        name_buf = create_string_buffer(name_bytes)
        if not isinstance(ty, FuncType):
            raise TypeError(&#34;expected a FuncType&#34;)
        idx = FUNCTIONS.allocate((func, ty.results, access_caller))
        error = ffi.wasmtime_linker_define_func(
            self._ptr,
            module_buf,
            len(module_bytes),
            name_buf,
            len(name_bytes),
            ty._ptr,
            trampoline,
            idx,
            finalize)
        if error:
            raise WasmtimeError._from_ptr(error)

    def define_instance(self, store: Storelike, name: str, instance: Instance) -&gt; None:
        &#34;&#34;&#34;
        Convenience wrapper to define an entire instance in this linker.

        This function will `define` eaech of the exports on the instance into
        this linker, using the name provided as the module name and the export&#39;s
        own name as the field name.

        This function will raise an error if `instance` comes from the wrong
        store or if shadowing is disallowed and a name was previously defined.
        &#34;&#34;&#34;
        if not isinstance(instance, Instance):
            raise TypeError(&#34;expected an `Instance`&#34;)
        name_bytes = name.encode(&#39;utf8&#39;)
        name_buf = create_string_buffer(name_bytes)
        error = ffi.wasmtime_linker_define_instance(self._ptr,
                                                    store._context,
                                                    name_buf,
                                                    len(name_bytes),
                                                    byref(instance._instance))
        if error:
            raise WasmtimeError._from_ptr(error)

    def define_wasi(self) -&gt; None:
        &#34;&#34;&#34;
        Defines a WASI instance in this linker.

        The instance provided has been previously constructed and this method
        will define all the appropriate imports and their names into this linker
        to assist with instantiating modules that use WASI.

        This function will raise an error if shadowing is disallowed and a name
        was previously defined.
        &#34;&#34;&#34;
        error = ffi.wasmtime_linker_define_wasi(self._ptr)
        if error:
            raise WasmtimeError._from_ptr(error)

    def define_module(self, store: Storelike, name: str, module: Module) -&gt; None:
        &#34;&#34;&#34;
        Defines automatic instantiations of the provided module in this linker.

        The `module` provided is defined under `name` with automatic
        instantiations which respect WASI Commands and Reactors.

        For more information see the Rust documentation at
        https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.module.

        This method will throw an error if shadowing is disallowed and an item
        has previously been defined.
        &#34;&#34;&#34;
        if not isinstance(module, Module):
            raise TypeError(&#34;expected a `Module`&#34;)
        name_bytes = name.encode(&#39;utf-8&#39;)
        name_buf = create_string_buffer(name_bytes)
        error = ffi.wasmtime_linker_module(self._ptr, store._context, name_buf, len(name_bytes), module._ptr)
        if error:
            raise WasmtimeError._from_ptr(error)

    def instantiate(self, store: Storelike, module: Module) -&gt; Instance:
        &#34;&#34;&#34;
        Instantiates a module using this linker&#39;s defined set of names.

        This method will attempt to satisfy all the imports of the `module`
        provided with the names defined within this linker. If all names are
        defined then the module is instantiated.

        Raises an error if an import of `module` hasn&#39;t been defined in this
        linker or if a trap happens while instantiating the instance.
        &#34;&#34;&#34;
        trap = POINTER(ffi.wasm_trap_t)()
        instance = ffi.wasmtime_instance_t()
        with enter_wasm(store) as trap:
            error = ffi.wasmtime_linker_instantiate(
                self._ptr, store._context, module._ptr, byref(instance), trap)
            if error:
                raise WasmtimeError._from_ptr(error)
        return Instance._from_raw(instance)

    def get_default(self, store: Storelike, name: str) -&gt; Func:
        &#34;&#34;&#34;
        Gets the default export for the named module in this linker.

        For more information on this see the Rust documentation at
        https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.get_default.

        Raises an error if the default export wasn&#39;t present.
        &#34;&#34;&#34;
        name_bytes = name.encode(&#39;utf-8&#39;)
        name_buf = create_string_buffer(name_bytes)
        func = ffi.wasmtime_func_t()
        error = ffi.wasmtime_linker_get_default(self._ptr, store._context,
                                                name_buf, len(name_bytes), byref(func))
        if error:
            raise WasmtimeError._from_ptr(error)
        return Func._from_raw(func)

    def get(self, store: Storelike, module: str, name: str) -&gt; AsExtern:
        &#34;&#34;&#34;
        Gets a singular item defined in this linker.

        Raises an error if this item hasn&#39;t been defined or if the item has been
        defined twice with different types.
        &#34;&#34;&#34;
        module_bytes = module.encode(&#39;utf-8&#39;)
        module_buf = create_string_buffer(module_bytes)
        name_bytes = name.encode(&#39;utf-8&#39;)
        name_buf = create_string_buffer(name_bytes)
        item = ffi.wasmtime_extern_t()
        ok = ffi.wasmtime_linker_get(self._ptr, store._context,
                                     module_buf, len(module_bytes),
                                     name_buf, len(name_bytes),
                                     byref(item))
        if ok:
            return wrap_extern(item)
        raise WasmtimeError(&#34;item not defined in linker&#34;)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasmtime_linker_delete(self._ptr)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="wasmtime.Linker.engine"><code class="name">var <span class="ident">engine</span> : wasmtime._engine.Engine</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Linker.allow_shadowing"><code class="name">var <span class="ident">allow_shadowing</span></code></dt>
<dd>
<div class="desc"><p>Configures whether definitions are allowed to shadow one another within
this linker</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Linker.define"><code class="name flex">
<span>def <span class="ident">define</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], module: str, name: str, item: Union[ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), ForwardRef('<a title="wasmtime.Table" href="#wasmtime.Table">Table</a>'), ForwardRef('<a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>'), ForwardRef('<a title="wasmtime.Global" href="#wasmtime.Global">Global</a>'), ForwardRef('<a title="wasmtime.Instance" href="#wasmtime.Instance">Instance</a>'), ForwardRef('<a title="wasmtime.Module" href="#wasmtime.Module">Module</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a new item, by name, in this linker.</p>
<p>This method will add a new definition to this linker. The <code>module</code> nad
<code>name</code> provided are what to name the <code>item</code> within the linker.</p>
<p>This function will raise an error if <code>item</code> comes from the wrong store
or if shadowing is disallowed and the module/name pair has already been
defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define(self, store: Storelike, module: str, name: str, item: AsExtern) -&gt; None:
    &#34;&#34;&#34;
    Defines a new item, by name, in this linker.

    This method will add a new definition to this linker. The `module` nad
    `name` provided are what to name the `item` within the linker.

    This function will raise an error if `item` comes from the wrong store
    or if shadowing is disallowed and the module/name pair has already been
    defined.
    &#34;&#34;&#34;
    raw_item = get_extern_ptr(item)
    module_bytes = module.encode(&#39;utf-8&#39;)
    module_buf = create_string_buffer(module_bytes)
    name_bytes = name.encode(&#39;utf-8&#39;)
    name_buf = create_string_buffer(name_bytes)
    error = ffi.wasmtime_linker_define(
        self._ptr,
        store._context,
        module_buf,
        len(module_bytes),
        name_buf,
        len(name_bytes),
        byref(raw_item))
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.define_func"><code class="name flex">
<span>def <span class="ident">define_func</span></span>(<span>self, module: str, name: str, ty: wasmtime._types.FuncType, func: Callable[..., Any], access_caller: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a new function, by name, in this linker.</p>
<p>This method is similar to <code>define</code> except that you can directly define a
function without creating a <code><a title="wasmtime.Func" href="#wasmtime.Func">Func</a></code> itself. This enables
<code><a title="wasmtime.Store" href="#wasmtime.Store">Store</a></code>-independent functions to be inserted into this linker, meaning
the linker can be used to instantiate modules in multiple stores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_func(self, module: str, name: str, ty: FuncType, func: Callable[..., Any], access_caller: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Defines a new function, by name, in this linker.

    This method is similar to `define` except that you can directly define a
    function without creating a `Func` itself. This enables
    `Store`-independent functions to be inserted into this linker, meaning
    the linker can be used to instantiate modules in multiple stores.
    &#34;&#34;&#34;
    module_bytes = module.encode(&#39;utf-8&#39;)
    module_buf = create_string_buffer(module_bytes)
    name_bytes = name.encode(&#39;utf-8&#39;)
    name_buf = create_string_buffer(name_bytes)
    if not isinstance(ty, FuncType):
        raise TypeError(&#34;expected a FuncType&#34;)
    idx = FUNCTIONS.allocate((func, ty.results, access_caller))
    error = ffi.wasmtime_linker_define_func(
        self._ptr,
        module_buf,
        len(module_bytes),
        name_buf,
        len(name_bytes),
        ty._ptr,
        trampoline,
        idx,
        finalize)
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.define_instance"><code class="name flex">
<span>def <span class="ident">define_instance</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], name: str, instance: wasmtime._instance.Instance) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience wrapper to define an entire instance in this linker.</p>
<p>This function will <code>define</code> eaech of the exports on the instance into
this linker, using the name provided as the module name and the export's
own name as the field name.</p>
<p>This function will raise an error if <code>instance</code> comes from the wrong
store or if shadowing is disallowed and a name was previously defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_instance(self, store: Storelike, name: str, instance: Instance) -&gt; None:
    &#34;&#34;&#34;
    Convenience wrapper to define an entire instance in this linker.

    This function will `define` eaech of the exports on the instance into
    this linker, using the name provided as the module name and the export&#39;s
    own name as the field name.

    This function will raise an error if `instance` comes from the wrong
    store or if shadowing is disallowed and a name was previously defined.
    &#34;&#34;&#34;
    if not isinstance(instance, Instance):
        raise TypeError(&#34;expected an `Instance`&#34;)
    name_bytes = name.encode(&#39;utf8&#39;)
    name_buf = create_string_buffer(name_bytes)
    error = ffi.wasmtime_linker_define_instance(self._ptr,
                                                store._context,
                                                name_buf,
                                                len(name_bytes),
                                                byref(instance._instance))
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.define_module"><code class="name flex">
<span>def <span class="ident">define_module</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], name: str, module: wasmtime._module.Module) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Defines automatic instantiations of the provided module in this linker.</p>
<p>The <code>module</code> provided is defined under <code>name</code> with automatic
instantiations which respect WASI Commands and Reactors.</p>
<p>For more information see the Rust documentation at
<a href="https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.module.">https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.module.</a></p>
<p>This method will throw an error if shadowing is disallowed and an item
has previously been defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_module(self, store: Storelike, name: str, module: Module) -&gt; None:
    &#34;&#34;&#34;
    Defines automatic instantiations of the provided module in this linker.

    The `module` provided is defined under `name` with automatic
    instantiations which respect WASI Commands and Reactors.

    For more information see the Rust documentation at
    https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.module.

    This method will throw an error if shadowing is disallowed and an item
    has previously been defined.
    &#34;&#34;&#34;
    if not isinstance(module, Module):
        raise TypeError(&#34;expected a `Module`&#34;)
    name_bytes = name.encode(&#39;utf-8&#39;)
    name_buf = create_string_buffer(name_bytes)
    error = ffi.wasmtime_linker_module(self._ptr, store._context, name_buf, len(name_bytes), module._ptr)
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.define_wasi"><code class="name flex">
<span>def <span class="ident">define_wasi</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a WASI instance in this linker.</p>
<p>The instance provided has been previously constructed and this method
will define all the appropriate imports and their names into this linker
to assist with instantiating modules that use WASI.</p>
<p>This function will raise an error if shadowing is disallowed and a name
was previously defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_wasi(self) -&gt; None:
    &#34;&#34;&#34;
    Defines a WASI instance in this linker.

    The instance provided has been previously constructed and this method
    will define all the appropriate imports and their names into this linker
    to assist with instantiating modules that use WASI.

    This function will raise an error if shadowing is disallowed and a name
    was previously defined.
    &#34;&#34;&#34;
    error = ffi.wasmtime_linker_define_wasi(self._ptr)
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], module: str, name: str) ‑> Union[<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>, <a title="wasmtime.Table" href="#wasmtime.Table">Table</a>, <a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>, <a title="wasmtime.Global" href="#wasmtime.Global">Global</a>, <a title="wasmtime.Instance" href="#wasmtime.Instance">Instance</a>, <a title="wasmtime.Module" href="#wasmtime.Module">Module</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a singular item defined in this linker.</p>
<p>Raises an error if this item hasn't been defined or if the item has been
defined twice with different types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, store: Storelike, module: str, name: str) -&gt; AsExtern:
    &#34;&#34;&#34;
    Gets a singular item defined in this linker.

    Raises an error if this item hasn&#39;t been defined or if the item has been
    defined twice with different types.
    &#34;&#34;&#34;
    module_bytes = module.encode(&#39;utf-8&#39;)
    module_buf = create_string_buffer(module_bytes)
    name_bytes = name.encode(&#39;utf-8&#39;)
    name_buf = create_string_buffer(name_bytes)
    item = ffi.wasmtime_extern_t()
    ok = ffi.wasmtime_linker_get(self._ptr, store._context,
                                 module_buf, len(module_bytes),
                                 name_buf, len(name_bytes),
                                 byref(item))
    if ok:
        return wrap_extern(item)
    raise WasmtimeError(&#34;item not defined in linker&#34;)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.get_default"><code class="name flex">
<span>def <span class="ident">get_default</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], name: str) ‑> wasmtime._func.Func</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the default export for the named module in this linker.</p>
<p>For more information on this see the Rust documentation at
<a href="https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.get_default.">https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.get_default.</a></p>
<p>Raises an error if the default export wasn't present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default(self, store: Storelike, name: str) -&gt; Func:
    &#34;&#34;&#34;
    Gets the default export for the named module in this linker.

    For more information on this see the Rust documentation at
    https://docs.wasmtime.dev/api/wasmtime/struct.Linker.html#method.get_default.

    Raises an error if the default export wasn&#39;t present.
    &#34;&#34;&#34;
    name_bytes = name.encode(&#39;utf-8&#39;)
    name_buf = create_string_buffer(name_bytes)
    func = ffi.wasmtime_func_t()
    error = ffi.wasmtime_linker_get_default(self._ptr, store._context,
                                            name_buf, len(name_bytes), byref(func))
    if error:
        raise WasmtimeError._from_ptr(error)
    return Func._from_raw(func)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.instantiate"><code class="name flex">
<span>def <span class="ident">instantiate</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], module: wasmtime._module.Module) ‑> wasmtime._instance.Instance</span>
</code></dt>
<dd>
<div class="desc"><p>Instantiates a module using this linker's defined set of names.</p>
<p>This method will attempt to satisfy all the imports of the <code>module</code>
provided with the names defined within this linker. If all names are
defined then the module is instantiated.</p>
<p>Raises an error if an import of <code>module</code> hasn't been defined in this
linker or if a trap happens while instantiating the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instantiate(self, store: Storelike, module: Module) -&gt; Instance:
    &#34;&#34;&#34;
    Instantiates a module using this linker&#39;s defined set of names.

    This method will attempt to satisfy all the imports of the `module`
    provided with the names defined within this linker. If all names are
    defined then the module is instantiated.

    Raises an error if an import of `module` hasn&#39;t been defined in this
    linker or if a trap happens while instantiating the instance.
    &#34;&#34;&#34;
    trap = POINTER(ffi.wasm_trap_t)()
    instance = ffi.wasmtime_instance_t()
    with enter_wasm(store) as trap:
        error = ffi.wasmtime_linker_instantiate(
            self._ptr, store._context, module._ptr, byref(instance), trap)
        if error:
            raise WasmtimeError._from_ptr(error)
    return Instance._from_raw(instance)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Memory"><code class="flex name class">
<span>class <span class="ident">Memory</span></span>
<span>(</span><span>store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], ty: wasmtime._types.MemoryType)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new memory in <code>store</code> with the given <code>ty</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Memory:
    _memory: ffi.wasmtime_memory_t

    def __init__(self, store: Storelike, ty: MemoryType):
        &#34;&#34;&#34;
        Creates a new memory in `store` with the given `ty`
        &#34;&#34;&#34;

        mem = ffi.wasmtime_memory_t()
        error = ffi.wasmtime_memory_new(store._context, ty._ptr, byref(mem))
        if error:
            raise WasmtimeError._from_ptr(error)
        self._memory = mem

    @classmethod
    def _from_raw(cls, mem: ffi.wasmtime_memory_t) -&gt; &#34;Memory&#34;:
        ty: &#34;Memory&#34; = cls.__new__(cls)
        ty._memory = mem
        return ty

    def type(self, store: Storelike) -&gt; MemoryType:
        &#34;&#34;&#34;
        Gets the type of this memory as a `MemoryType`
        &#34;&#34;&#34;

        ptr = ffi.wasmtime_memory_type(store._context, byref(self._memory))
        return MemoryType._from_ptr(ptr, None)

    def grow(self, store: Storelike, delta: int) -&gt; int:
        &#34;&#34;&#34;
        Grows this memory by the given number of pages
        &#34;&#34;&#34;

        if delta &lt; 0:
            raise WasmtimeError(&#34;cannot grow by negative amount&#34;)
        prev = ffi.c_uint64(0)
        error = ffi.wasmtime_memory_grow(store._context, byref(self._memory), delta, byref(prev))
        if error:
            raise WasmtimeError._from_ptr(error)
        return prev.value

    def size(self, store: Storelike) -&gt; int:
        &#34;&#34;&#34;
        Returns the size, in WebAssembly pages, of this memory.
        &#34;&#34;&#34;

        return ffi.wasmtime_memory_size(store._context, byref(self._memory))

    def data_ptr(self, store: Storelike) -&gt; &#34;ctypes._Pointer[c_ubyte]&#34;:
        &#34;&#34;&#34;
        Returns the raw pointer in memory where this wasm memory lives.

        Remember that all accesses to wasm memory should be bounds-checked
        against the `data_len` method.
        &#34;&#34;&#34;
        return ffi.wasmtime_memory_data(store._context, byref(self._memory))

    def get_buffer_ptr(self, store: Storelike,
                       size: typing.Optional[int] = None,
                       offset: int = 0) -&gt; ctypes.Array:
        &#34;&#34;&#34;
        return raw pointer to buffer suitable for creating zero-copy writable NumPy Buffer Protocol
        this method is also used internally by `read()` and `write()`

        np_mem = np.frombuffer(memory.get_buffer_ptr(store), dtype=np.uint8)
        np_mem[start:end] = A # write
        B = np_mem[start:end] # read
        &#34;&#34;&#34;
        if size is None:
            size = self.data_len(store)
        ptr_type = ctypes.c_ubyte * size
        return ptr_type.from_address(ctypes.addressof(self.data_ptr(store).contents) + offset)

    def read(
            self,
            store: Storelike,
            start: typing.Optional[int] = 0,
            stop: typing.Optional[int] = None) -&gt; bytearray:
        &#34;&#34;&#34;
        Reads this memory starting from `start` and up to `stop`
        and returns a copy of the contents as a `bytearray`.

        The indexing behavior of this method is similar to `list[start:stop]`
        where negative starts can be used to read from the end, for example.
        &#34;&#34;&#34;
        size = self.data_len(store)
        key = slice(start, stop, None)
        start, stop, _ = key.indices(size)
        val_size = stop - start
        if val_size &lt;= 0:
            # return bytearray of size zero
            return bytearray(0)
        src_ptr = self.get_buffer_ptr(store, val_size, start)
        return bytearray(src_ptr)

    def write(
            self,
            store: Storelike,
            value: typing.Union[bytearray, bytes],
            start: typing.Optional[int] = None) -&gt; int:
        &#34;&#34;&#34;
        write a bytearray value into a possibly large slice of memory
        negative start is allowed in a way similat to list slice mylist[-10:]
        if value is not bytearray it will be used to construct an intermediate bytearray (copyied twice)
        return number of bytes written
        raises IndexError when trying to write outside the memory range
        this happens when start offset is &gt;= size or when end side of value is &gt;= size
        &#34;&#34;&#34;
        size = self.data_len(store)
        key = slice(start, None)
        start = key.indices(size)[0]
        if start &gt;= size:
            raise IndexError(&#34;index out of range&#34;)
        # value must be bytearray ex. cast bytes() to bytearray
        if not isinstance(value, bytearray):
            value = bytearray(value)
        val_size = len(value)
        if val_size == 0:
            return val_size
        # stop is exclusive
        stop = start + val_size
        if stop &gt; size:
            raise IndexError(&#34;index out of range&#34;)
        ptr_type = ctypes.c_ubyte * val_size
        src_ptr = ptr_type.from_buffer(value)
        dst_ptr = self.get_buffer_ptr(store, val_size, start)
        ctypes.memmove(dst_ptr, src_ptr, val_size)
        return val_size

    def data_len(self, store: Storelike) -&gt; int:
        &#34;&#34;&#34;
        Returns the raw byte length of this memory.
        &#34;&#34;&#34;

        return ffi.wasmtime_memory_data_size(store._context, byref(self._memory))

    def _as_extern(self) -&gt; ffi.wasmtime_extern_t:
        union = ffi.wasmtime_extern_union(memory=self._memory)
        return ffi.wasmtime_extern_t(ffi.WASMTIME_EXTERN_MEMORY, union)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Memory.data_len"><code class="name flex">
<span>def <span class="ident">data_len</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the raw byte length of this memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_len(self, store: Storelike) -&gt; int:
    &#34;&#34;&#34;
    Returns the raw byte length of this memory.
    &#34;&#34;&#34;

    return ffi.wasmtime_memory_data_size(store._context, byref(self._memory))</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.data_ptr"><code class="name flex">
<span>def <span class="ident">data_ptr</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> ctypes._Pointer[c_ubyte]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the raw pointer in memory where this wasm memory lives.</p>
<p>Remember that all accesses to wasm memory should be bounds-checked
against the <code>data_len</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_ptr(self, store: Storelike) -&gt; &#34;ctypes._Pointer[c_ubyte]&#34;:
    &#34;&#34;&#34;
    Returns the raw pointer in memory where this wasm memory lives.

    Remember that all accesses to wasm memory should be bounds-checked
    against the `data_len` method.
    &#34;&#34;&#34;
    return ffi.wasmtime_memory_data(store._context, byref(self._memory))</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.get_buffer_ptr"><code class="name flex">
<span>def <span class="ident">get_buffer_ptr</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], size: Optional[int] = None, offset: int = 0) ‑> _ctypes.Array</span>
</code></dt>
<dd>
<div class="desc"><p>return raw pointer to buffer suitable for creating zero-copy writable NumPy Buffer Protocol
this method is also used internally by <code>read()</code> and <code>write()</code></p>
<p>np_mem = np.frombuffer(memory.get_buffer_ptr(store), dtype=np.uint8)
np_mem[start:end] = A # write
B = np_mem[start:end] # read</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buffer_ptr(self, store: Storelike,
                   size: typing.Optional[int] = None,
                   offset: int = 0) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    return raw pointer to buffer suitable for creating zero-copy writable NumPy Buffer Protocol
    this method is also used internally by `read()` and `write()`

    np_mem = np.frombuffer(memory.get_buffer_ptr(store), dtype=np.uint8)
    np_mem[start:end] = A # write
    B = np_mem[start:end] # read
    &#34;&#34;&#34;
    if size is None:
        size = self.data_len(store)
    ptr_type = ctypes.c_ubyte * size
    return ptr_type.from_address(ctypes.addressof(self.data_ptr(store).contents) + offset)</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], delta: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Grows this memory by the given number of pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grow(self, store: Storelike, delta: int) -&gt; int:
    &#34;&#34;&#34;
    Grows this memory by the given number of pages
    &#34;&#34;&#34;

    if delta &lt; 0:
        raise WasmtimeError(&#34;cannot grow by negative amount&#34;)
    prev = ffi.c_uint64(0)
    error = ffi.wasmtime_memory_grow(store._context, byref(self._memory), delta, byref(prev))
    if error:
        raise WasmtimeError._from_ptr(error)
    return prev.value</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], start: Optional[int] = 0, stop: Optional[int] = None) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>Reads this memory starting from <code>start</code> and up to <code>stop</code>
and returns a copy of the contents as a <code>bytearray</code>.</p>
<p>The indexing behavior of this method is similar to <code>list[start:stop]</code>
where negative starts can be used to read from the end, for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(
        self,
        store: Storelike,
        start: typing.Optional[int] = 0,
        stop: typing.Optional[int] = None) -&gt; bytearray:
    &#34;&#34;&#34;
    Reads this memory starting from `start` and up to `stop`
    and returns a copy of the contents as a `bytearray`.

    The indexing behavior of this method is similar to `list[start:stop]`
    where negative starts can be used to read from the end, for example.
    &#34;&#34;&#34;
    size = self.data_len(store)
    key = slice(start, stop, None)
    start, stop, _ = key.indices(size)
    val_size = stop - start
    if val_size &lt;= 0:
        # return bytearray of size zero
        return bytearray(0)
    src_ptr = self.get_buffer_ptr(store, val_size, start)
    return bytearray(src_ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size, in WebAssembly pages, of this memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self, store: Storelike) -&gt; int:
    &#34;&#34;&#34;
    Returns the size, in WebAssembly pages, of this memory.
    &#34;&#34;&#34;

    return ffi.wasmtime_memory_size(store._context, byref(self._memory))</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> wasmtime._types.MemoryType</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the type of this memory as a <code><a title="wasmtime.MemoryType" href="#wasmtime.MemoryType">MemoryType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(self, store: Storelike) -&gt; MemoryType:
    &#34;&#34;&#34;
    Gets the type of this memory as a `MemoryType`
    &#34;&#34;&#34;

    ptr = ffi.wasmtime_memory_type(store._context, byref(self._memory))
    return MemoryType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], value: Union[bytearray, bytes], start: Optional[int] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>write a bytearray value into a possibly large slice of memory
negative start is allowed in a way similat to list slice mylist[-10:]
if value is not bytearray it will be used to construct an intermediate bytearray (copyied twice)
return number of bytes written
raises IndexError when trying to write outside the memory range
this happens when start offset is &gt;= size or when end side of value is &gt;= size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(
        self,
        store: Storelike,
        value: typing.Union[bytearray, bytes],
        start: typing.Optional[int] = None) -&gt; int:
    &#34;&#34;&#34;
    write a bytearray value into a possibly large slice of memory
    negative start is allowed in a way similat to list slice mylist[-10:]
    if value is not bytearray it will be used to construct an intermediate bytearray (copyied twice)
    return number of bytes written
    raises IndexError when trying to write outside the memory range
    this happens when start offset is &gt;= size or when end side of value is &gt;= size
    &#34;&#34;&#34;
    size = self.data_len(store)
    key = slice(start, None)
    start = key.indices(size)[0]
    if start &gt;= size:
        raise IndexError(&#34;index out of range&#34;)
    # value must be bytearray ex. cast bytes() to bytearray
    if not isinstance(value, bytearray):
        value = bytearray(value)
    val_size = len(value)
    if val_size == 0:
        return val_size
    # stop is exclusive
    stop = start + val_size
    if stop &gt; size:
        raise IndexError(&#34;index out of range&#34;)
    ptr_type = ctypes.c_ubyte * val_size
    src_ptr = ptr_type.from_buffer(value)
    dst_ptr = self.get_buffer_ptr(store, val_size, start)
    ctypes.memmove(dst_ptr, src_ptr, val_size)
    return val_size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.MemoryType"><code class="flex name class">
<span>class <span class="ident">MemoryType</span></span>
<span>(</span><span>limits: wasmtime._types.Limits, is_64: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryType:
    def __init__(self, limits: Limits, is_64: bool = False):
        if not isinstance(limits, Limits):
            raise TypeError(&#34;expected Limits&#34;)
        if is_64:
            maximum = 0x10000000000000000
        else:
            maximum = 0x100000000
        if limits.min &gt;= maximum:
            raise WasmtimeError(&#34;minimum size too large&#34;)
        if limits.max and limits.max &gt;= maximum:
            raise WasmtimeError(&#34;maximum size too large&#34;)
        ptr = ffi.wasmtime_memorytype_new(limits.min,
                                          limits.max is not None,
                                          limits.max if limits.max else 0,
                                          is_64)
        if not ptr:
            raise WasmtimeError(&#34;failed to allocate MemoryType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasm_memorytype_t]&#34;, owner: Optional[Any]) -&gt; &#34;MemoryType&#34;:
        ty: &#34;MemoryType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_memorytype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def limits(self) -&gt; Limits:
        &#34;&#34;&#34;
        Returns the limits on the size of this table
        &#34;&#34;&#34;
        minimum = ffi.wasmtime_memorytype_minimum(self._ptr)
        maximum = ffi.c_uint64(0)
        has_max = ffi.wasmtime_memorytype_maximum(self._ptr, byref(maximum))
        return Limits(minimum, maximum.value if has_max else None)

    @property
    def is_64(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether or not this is a 64-bit memory
        &#34;&#34;&#34;
        return ffi.wasmtime_memorytype_is64(self._ptr)

    def _as_extern(self) -&gt; &#34;ctypes._Pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_memorytype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_memorytype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.MemoryType.is_64"><code class="name">var <span class="ident">is_64</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns whether or not this is a 64-bit memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_64(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns whether or not this is a 64-bit memory
    &#34;&#34;&#34;
    return ffi.wasmtime_memorytype_is64(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.MemoryType.limits"><code class="name">var <span class="ident">limits</span> : wasmtime._types.Limits</code></dt>
<dd>
<div class="desc"><p>Returns the limits on the size of this table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def limits(self) -&gt; Limits:
    &#34;&#34;&#34;
    Returns the limits on the size of this table
    &#34;&#34;&#34;
    minimum = ffi.wasmtime_memorytype_minimum(self._ptr)
    maximum = ffi.c_uint64(0)
    has_max = ffi.wasmtime_memorytype_maximum(self._ptr, byref(maximum))
    return Limits(minimum, maximum.value if has_max else None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Module"><code class="flex name class">
<span>class <span class="ident">Module</span></span>
<span>(</span><span>engine: wasmtime._engine.Engine, wasm: Union[str, bytes])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Module:
    @classmethod
    def from_file(cls, engine: Engine, path: str) -&gt; &#34;Module&#34;:
        &#34;&#34;&#34;
        Compiles and creates a new `Module` by reading the file at `path` and
        then delegating to the `Module` constructor.
        &#34;&#34;&#34;

        with open(path, &#34;rb&#34;) as f:
            contents = f.read()
        return cls(engine, contents)

    def __init__(self, engine: Engine, wasm: typing.Union[str, bytes]):
        if not isinstance(engine, Engine):
            raise TypeError(&#34;expected an Engine&#34;)

        # If this looks like a string, parse it as the text format. Note that
        # in python 2 strings and bytes are basically the same, so we skip this
        # if the first byte in the string is 0, meaning this is actually a wasm
        # module.
        if isinstance(wasm, str) and len(wasm) &gt; 0 and ord(wasm[0]) != 0:
            wasm = wat2wasm(wasm)
        if isinstance(wasm, bytes) and len(wasm) &gt; 0 and wasm[0] != 0:
            wasm = wat2wasm(wasm)

        if not isinstance(wasm, (bytes, bytearray)):
            raise TypeError(&#34;expected wasm bytes&#34;)

        # TODO: can the copy be avoided here? I can&#39;t for the life of me
        # figure this out.
        binary = (c_uint8 * len(wasm)).from_buffer_copy(wasm)
        ptr = POINTER(ffi.wasmtime_module_t)()
        error = ffi.wasmtime_module_new(engine._ptr, binary, len(wasm), byref(ptr))
        if error:
            raise WasmtimeError._from_ptr(error)
        self._ptr = ptr

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasmtime_module_t]&#34;) -&gt; &#34;Module&#34;:
        ty: &#34;Module&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasmtime_module_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        return ty

    @classmethod
    def deserialize(cls, engine: Engine, encoded: typing.Union[bytes, bytearray]) -&gt; &#39;Module&#39;:
        &#34;&#34;&#34;
        Deserializes bytes previously created by `Module.serialize`.

        This constructor for `Module` will deserialize bytes previously created
        by a serialized module. This will only succeed if the bytes were
        previously created by the same version of `wasmtime` as well as the
        same configuration within `Engine`.
        &#34;&#34;&#34;

        if not isinstance(encoded, (bytes, bytearray)):
            raise TypeError(&#34;expected bytes&#34;)

        ptr = POINTER(ffi.wasmtime_module_t)()

        # TODO: can the copy be avoided here? I can&#39;t for the life of me
        # figure this out.
        error = ffi.wasmtime_module_deserialize(
            engine._ptr,
            (c_uint8 * len(encoded)).from_buffer_copy(encoded),
            len(encoded),
            byref(ptr))
        if error:
            raise WasmtimeError._from_ptr(error)
        ret: &#34;Module&#34; = cls.__new__(cls)
        ret._ptr = ptr
        return ret

    @classmethod
    def deserialize_file(cls, engine: Engine, path: str) -&gt; &#39;Module&#39;:
        &#34;&#34;&#34;
        Deserializes bytes previously created by `Module.serialize` that are
        stored in a file on the filesystem.

        Otherwise this function is the same as `Module.deserialize`.
        &#34;&#34;&#34;

        ptr = POINTER(ffi.wasmtime_module_t)()
        path_bytes = path.encode(&#39;utf-8&#39;)
        error = ffi.wasmtime_module_deserialize_file(
            engine._ptr,
            path_bytes,
            byref(ptr))
        if error:
            raise WasmtimeError._from_ptr(error)
        ret: &#34;Module&#34; = cls.__new__(cls)
        ret._ptr = ptr
        return ret

    @classmethod
    def validate(cls, engine: Engine, wasm: typing.Union[bytes, bytearray]) -&gt; None:
        &#34;&#34;&#34;
        Validates whether the list of bytes `wasm` provided is a valid
        WebAssembly binary given the configuration in `store`

        Raises a `WasmtimeError` if the wasm isn&#39;t valid.
        &#34;&#34;&#34;

        if not isinstance(wasm, (bytes, bytearray)):
            raise TypeError(&#34;expected wasm bytes&#34;)

        # TODO: can the copy be avoided here? I can&#39;t for the life of me
        # figure this out.
        buf = (c_uint8 * len(wasm)).from_buffer_copy(wasm)
        error = ffi.wasmtime_module_validate(engine._ptr, buf, len(wasm))

        if error:
            raise WasmtimeError._from_ptr(error)

#     @property
#     def type(self) -&gt; ModuleType:
#         &#34;&#34;&#34;
#         Gets the type of this module as a `ModuleType`
#         &#34;&#34;&#34;

#         ptr = ffi.wasmtime_module_type(self._ptr)
#         return ModuleType._from_ptr(ptr, None)

    @property
    def imports(self) -&gt; typing.List[ImportType]:
        &#34;&#34;&#34;
        Returns the types of imports that this module has
        &#34;&#34;&#34;

        imports = ImportTypeList()
        ffi.wasmtime_module_imports(self._ptr, byref(imports.vec))
        ret = []
        for i in range(0, imports.vec.size):
            ret.append(ImportType._from_ptr(imports.vec.data[i], imports))
        return ret

    @property
    def exports(self) -&gt; typing.List[ExportType]:
        &#34;&#34;&#34;
        Returns the types of the exports that this module has
        &#34;&#34;&#34;

        exports = ExportTypeList()
        ffi.wasmtime_module_exports(self._ptr, byref(exports.vec))
        ret = []
        for i in range(0, exports.vec.size):
            ret.append(ExportType._from_ptr(exports.vec.data[i], exports))
        return ret

    def serialize(self) -&gt; bytearray:
        &#34;&#34;&#34;
        Serializes this module to a binary representation.

        This method will serialize this module to an in-memory byte array which
        can be cached and later passed to `Module.deserialize` to recreate this
        module.
        &#34;&#34;&#34;
        raw = ffi.wasm_byte_vec_t()
        err = ffi.wasmtime_module_serialize(self._ptr, byref(raw))
        if err:
            raise WasmtimeError._from_ptr(err)
        ret = ffi.to_bytes(raw)
        ffi.wasm_byte_vec_delete(byref(raw))
        return ret

    def _as_extern(self) -&gt; ffi.wasmtime_extern_t:
        union = ffi.wasmtime_extern_union(module=self._ptr)
        return ffi.wasmtime_extern_t(ffi.WASMTIME_EXTERN_MODULE, union)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasmtime_module_delete(self._ptr)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="wasmtime.Module.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>engine: wasmtime._engine.Engine, encoded: Union[bytearray, bytes]) ‑> wasmtime._module.Module</span>
</code></dt>
<dd>
<div class="desc"><p>Deserializes bytes previously created by <code><a title="wasmtime.Module.serialize" href="#wasmtime.Module.serialize">Module.serialize()</a></code>.</p>
<p>This constructor for <code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code> will deserialize bytes previously created
by a serialized module. This will only succeed if the bytes were
previously created by the same version of <code><a title="wasmtime" href="#wasmtime">wasmtime</a></code> as well as the
same configuration within <code><a title="wasmtime.Engine" href="#wasmtime.Engine">Engine</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def deserialize(cls, engine: Engine, encoded: typing.Union[bytes, bytearray]) -&gt; &#39;Module&#39;:
    &#34;&#34;&#34;
    Deserializes bytes previously created by `Module.serialize`.

    This constructor for `Module` will deserialize bytes previously created
    by a serialized module. This will only succeed if the bytes were
    previously created by the same version of `wasmtime` as well as the
    same configuration within `Engine`.
    &#34;&#34;&#34;

    if not isinstance(encoded, (bytes, bytearray)):
        raise TypeError(&#34;expected bytes&#34;)

    ptr = POINTER(ffi.wasmtime_module_t)()

    # TODO: can the copy be avoided here? I can&#39;t for the life of me
    # figure this out.
    error = ffi.wasmtime_module_deserialize(
        engine._ptr,
        (c_uint8 * len(encoded)).from_buffer_copy(encoded),
        len(encoded),
        byref(ptr))
    if error:
        raise WasmtimeError._from_ptr(error)
    ret: &#34;Module&#34; = cls.__new__(cls)
    ret._ptr = ptr
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Module.deserialize_file"><code class="name flex">
<span>def <span class="ident">deserialize_file</span></span>(<span>engine: wasmtime._engine.Engine, path: str) ‑> wasmtime._module.Module</span>
</code></dt>
<dd>
<div class="desc"><p>Deserializes bytes previously created by <code><a title="wasmtime.Module.serialize" href="#wasmtime.Module.serialize">Module.serialize()</a></code> that are
stored in a file on the filesystem.</p>
<p>Otherwise this function is the same as <code><a title="wasmtime.Module.deserialize" href="#wasmtime.Module.deserialize">Module.deserialize()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def deserialize_file(cls, engine: Engine, path: str) -&gt; &#39;Module&#39;:
    &#34;&#34;&#34;
    Deserializes bytes previously created by `Module.serialize` that are
    stored in a file on the filesystem.

    Otherwise this function is the same as `Module.deserialize`.
    &#34;&#34;&#34;

    ptr = POINTER(ffi.wasmtime_module_t)()
    path_bytes = path.encode(&#39;utf-8&#39;)
    error = ffi.wasmtime_module_deserialize_file(
        engine._ptr,
        path_bytes,
        byref(ptr))
    if error:
        raise WasmtimeError._from_ptr(error)
    ret: &#34;Module&#34; = cls.__new__(cls)
    ret._ptr = ptr
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Module.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>engine: wasmtime._engine.Engine, path: str) ‑> wasmtime._module.Module</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles and creates a new <code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code> by reading the file at <code>path</code> and
then delegating to the <code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, engine: Engine, path: str) -&gt; &#34;Module&#34;:
    &#34;&#34;&#34;
    Compiles and creates a new `Module` by reading the file at `path` and
    then delegating to the `Module` constructor.
    &#34;&#34;&#34;

    with open(path, &#34;rb&#34;) as f:
        contents = f.read()
    return cls(engine, contents)</code></pre>
</details>
</dd>
<dt id="wasmtime.Module.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>engine: wasmtime._engine.Engine, wasm: Union[bytearray, bytes]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Validates whether the list of bytes <code>wasm</code> provided is a valid
WebAssembly binary given the configuration in <code>store</code></p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if the wasm isn't valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate(cls, engine: Engine, wasm: typing.Union[bytes, bytearray]) -&gt; None:
    &#34;&#34;&#34;
    Validates whether the list of bytes `wasm` provided is a valid
    WebAssembly binary given the configuration in `store`

    Raises a `WasmtimeError` if the wasm isn&#39;t valid.
    &#34;&#34;&#34;

    if not isinstance(wasm, (bytes, bytearray)):
        raise TypeError(&#34;expected wasm bytes&#34;)

    # TODO: can the copy be avoided here? I can&#39;t for the life of me
    # figure this out.
    buf = (c_uint8 * len(wasm)).from_buffer_copy(wasm)
    error = ffi.wasmtime_module_validate(engine._ptr, buf, len(wasm))

    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Module.exports"><code class="name">var <span class="ident">exports</span> : List[wasmtime._types.ExportType]</code></dt>
<dd>
<div class="desc"><p>Returns the types of the exports that this module has</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exports(self) -&gt; typing.List[ExportType]:
    &#34;&#34;&#34;
    Returns the types of the exports that this module has
    &#34;&#34;&#34;

    exports = ExportTypeList()
    ffi.wasmtime_module_exports(self._ptr, byref(exports.vec))
    ret = []
    for i in range(0, exports.vec.size):
        ret.append(ExportType._from_ptr(exports.vec.data[i], exports))
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Module.imports"><code class="name">var <span class="ident">imports</span> : List[wasmtime._types.ImportType]</code></dt>
<dd>
<div class="desc"><p>Returns the types of imports that this module has</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def imports(self) -&gt; typing.List[ImportType]:
    &#34;&#34;&#34;
    Returns the types of imports that this module has
    &#34;&#34;&#34;

    imports = ImportTypeList()
    ffi.wasmtime_module_imports(self._ptr, byref(imports.vec))
    ret = []
    for i in range(0, imports.vec.size):
        ret.append(ImportType._from_ptr(imports.vec.data[i], imports))
    return ret</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Module.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>Serializes this module to a binary representation.</p>
<p>This method will serialize this module to an in-memory byte array which
can be cached and later passed to <code><a title="wasmtime.Module.deserialize" href="#wasmtime.Module.deserialize">Module.deserialize()</a></code> to recreate this
module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; bytearray:
    &#34;&#34;&#34;
    Serializes this module to a binary representation.

    This method will serialize this module to an in-memory byte array which
    can be cached and later passed to `Module.deserialize` to recreate this
    module.
    &#34;&#34;&#34;
    raw = ffi.wasm_byte_vec_t()
    err = ffi.wasmtime_module_serialize(self._ptr, byref(raw))
    if err:
        raise WasmtimeError._from_ptr(err)
    ret = ffi.to_bytes(raw)
    ffi.wasm_byte_vec_delete(byref(raw))
    return ret</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Store"><code class="flex name class">
<span>class <span class="ident">Store</span></span>
<span>(</span><span>engine: Optional[wasmtime._engine.Engine] = None, data: Optional[Any] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Store:
    _ptr: &#34;ctypes._Pointer[ffi.wasmtime_store_t]&#34;
    _context: &#34;ctypes._Pointer[ffi.wasmtime_context_t]&#34;

    def __init__(self, engine: typing.Optional[Engine] = None, data: typing.Optional[typing.Any] = None):

        if engine is None:
            engine = Engine()
        elif not isinstance(engine, Engine):
            raise TypeError(&#34;expected an Engine&#34;)
        data_id = ffi.c_void_p(0)
        finalize = cast(0, CFUNCTYPE(None, c_void_p))
        if data:
            data_id = value._intern(data)
            finalize = value._externref_finalizer
        self._ptr = ffi.wasmtime_store_new(engine._ptr, data_id, finalize)
        self._context = ffi.wasmtime_store_context(self._ptr)
        self.engine = engine

    def data(self) -&gt; typing.Optional[typing.Any]:
        &#34;&#34;&#34;
        TODO
        &#34;&#34;&#34;
        data = ffi.wasmtime_context_get_data(self._context)
        if data:
            return value._unintern(data)
        else:
            return None

    def gc(self) -&gt; None:
        &#34;&#34;&#34;
        Runs a GC over `externref` values that have been passed into this Store,
        cleaning out anything that is no longer referenced.

        This is not required to be run manually, but can be done so if you&#39;d
        like more precise control over when unreferenced `externref` values are
        deallocated.
        &#34;&#34;&#34;
        ffi.wasmtime_context_gc(self._context)

    def add_fuel(self, fuel: int) -&gt; None:
        &#34;&#34;&#34;
        Adds the specified amount of fuel into this store.

        This is only relevant when `Config.consume_fuel` is configured.

        This is a required call to ensure that the store has fuel to
        execute WebAssembly since otherwise stores start with zero fuel.

        Raises a `WasmtimeError` if this store&#39;s configuration is not configured
        to consume fuel.
        &#34;&#34;&#34;
        err = ffi.wasmtime_context_add_fuel(self._context, fuel)
        if err:
            raise WasmtimeError._from_ptr(err)

    def fuel_consumed(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the amount of fuel consumed by this `Store` so far.

        Raises a `WasmtimeError` if this store&#39;s configuration is not configured
        to consume fuel.
        &#34;&#34;&#34;
        fuel = c_uint64(0)
        ok = ffi.wasmtime_context_fuel_consumed(self._context, byref(fuel))
        if ok:
            return fuel.value
        raise WasmtimeError(&#34;fuel is not enabled in this store&#39;s configuration&#34;)

    def consume_fuel(self, fuel: int) -&gt; int:
        &#34;&#34;&#34;
        Consumes the specified amount of fuel from this store.

        This is only relevant when `Config.consume_fuel` is configured.

        Raises a `WasmtimeError` if this store&#39;s configuration is not configured
        to consume fuel or if the store doesn&#39;t have enough fuel remaining.

        Returns the remaining amount of fuel left in the store.
        &#34;&#34;&#34;
        remaining = c_uint64(0)
        err = ffi.wasmtime_context_consume_fuel(self._context, fuel, byref(remaining))
        if err:
            raise WasmtimeError._from_ptr(err)
        return remaining.value

    def set_wasi(self, wasi: &#34;WasiConfig&#34;) -&gt; None:
        &#34;&#34;&#34;
        TODO
        &#34;&#34;&#34;
        error = ffi.wasmtime_context_set_wasi(self._context, wasi._ptr)
        delattr(wasi, &#39;_ptr&#39;)
        if error:
            raise WasmtimeError._from_ptr(error)

    def set_epoch_deadline(self, ticks_after_current: int) -&gt; None:
        &#34;&#34;&#34;
        Configures the relative epoch deadline, after the current engine&#39;s
        epoch, after which WebAssembly code will trap.
        &#34;&#34;&#34;
        ffi.wasmtime_context_set_epoch_deadline(self._context, ticks_after_current)

    def set_limits(self,
                   memory_size: int = -1,
                   table_elements: int = -1,
                   instances: int = -1,
                   tables: int = -1,
                   memories: int = -1) -&gt; None:
        &#34;&#34;&#34;
        Configures the limits of various items within this store.

        * `memory_size` - the maximum size, in bytes, that linear memory is
          allowed to consume within this store. Setting this to a lower value
          will cause instantiation to fail if a module needs more memory.
          Additionally the `memory.grow` instruction will return -1 once this
          threshold is reached.

        * `table_elements` - the maximum number of elements that can be stored
          within tables in this store. Currently each table element takes 8
          bytes.

        * `instances` - the maximum number of WebAssembly instances that can
          be created.

        * `tables` - the maximum number of WebAssembly tables that can
          be created.

        * `memories` - the maximum number of WebAssembly linear memories that
          can be created.

        If any limit is negative then the limit will not be set as a part of
        this invocation and it will be ignored.
        &#34;&#34;&#34;
        ffi.wasmtime_store_limiter(self._ptr, memory_size, table_elements, instances, tables, memories)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasmtime_store_delete(self._ptr)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Store.add_fuel"><code class="name flex">
<span>def <span class="ident">add_fuel</span></span>(<span>self, fuel: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the specified amount of fuel into this store.</p>
<p>This is only relevant when <code><a title="wasmtime.Config.consume_fuel" href="#wasmtime.Config.consume_fuel">Config.consume_fuel</a></code> is configured.</p>
<p>This is a required call to ensure that the store has fuel to
execute WebAssembly since otherwise stores start with zero fuel.</p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if this store's configuration is not configured
to consume fuel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fuel(self, fuel: int) -&gt; None:
    &#34;&#34;&#34;
    Adds the specified amount of fuel into this store.

    This is only relevant when `Config.consume_fuel` is configured.

    This is a required call to ensure that the store has fuel to
    execute WebAssembly since otherwise stores start with zero fuel.

    Raises a `WasmtimeError` if this store&#39;s configuration is not configured
    to consume fuel.
    &#34;&#34;&#34;
    err = ffi.wasmtime_context_add_fuel(self._context, fuel)
    if err:
        raise WasmtimeError._from_ptr(err)</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.consume_fuel"><code class="name flex">
<span>def <span class="ident">consume_fuel</span></span>(<span>self, fuel: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Consumes the specified amount of fuel from this store.</p>
<p>This is only relevant when <code><a title="wasmtime.Config.consume_fuel" href="#wasmtime.Config.consume_fuel">Config.consume_fuel</a></code> is configured.</p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if this store's configuration is not configured
to consume fuel or if the store doesn't have enough fuel remaining.</p>
<p>Returns the remaining amount of fuel left in the store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consume_fuel(self, fuel: int) -&gt; int:
    &#34;&#34;&#34;
    Consumes the specified amount of fuel from this store.

    This is only relevant when `Config.consume_fuel` is configured.

    Raises a `WasmtimeError` if this store&#39;s configuration is not configured
    to consume fuel or if the store doesn&#39;t have enough fuel remaining.

    Returns the remaining amount of fuel left in the store.
    &#34;&#34;&#34;
    remaining = c_uint64(0)
    err = ffi.wasmtime_context_consume_fuel(self._context, fuel, byref(remaining))
    if err:
        raise WasmtimeError._from_ptr(err)
    return remaining.value</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self) ‑> Optional[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>TODO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self) -&gt; typing.Optional[typing.Any]:
    &#34;&#34;&#34;
    TODO
    &#34;&#34;&#34;
    data = ffi.wasmtime_context_get_data(self._context)
    if data:
        return value._unintern(data)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.fuel_consumed"><code class="name flex">
<span>def <span class="ident">fuel_consumed</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the amount of fuel consumed by this <code><a title="wasmtime.Store" href="#wasmtime.Store">Store</a></code> so far.</p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if this store's configuration is not configured
to consume fuel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fuel_consumed(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the amount of fuel consumed by this `Store` so far.

    Raises a `WasmtimeError` if this store&#39;s configuration is not configured
    to consume fuel.
    &#34;&#34;&#34;
    fuel = c_uint64(0)
    ok = ffi.wasmtime_context_fuel_consumed(self._context, byref(fuel))
    if ok:
        return fuel.value
    raise WasmtimeError(&#34;fuel is not enabled in this store&#39;s configuration&#34;)</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.gc"><code class="name flex">
<span>def <span class="ident">gc</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a GC over <code>externref</code> values that have been passed into this Store,
cleaning out anything that is no longer referenced.</p>
<p>This is not required to be run manually, but can be done so if you'd
like more precise control over when unreferenced <code>externref</code> values are
deallocated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gc(self) -&gt; None:
    &#34;&#34;&#34;
    Runs a GC over `externref` values that have been passed into this Store,
    cleaning out anything that is no longer referenced.

    This is not required to be run manually, but can be done so if you&#39;d
    like more precise control over when unreferenced `externref` values are
    deallocated.
    &#34;&#34;&#34;
    ffi.wasmtime_context_gc(self._context)</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.set_epoch_deadline"><code class="name flex">
<span>def <span class="ident">set_epoch_deadline</span></span>(<span>self, ticks_after_current: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the relative epoch deadline, after the current engine's
epoch, after which WebAssembly code will trap.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_epoch_deadline(self, ticks_after_current: int) -&gt; None:
    &#34;&#34;&#34;
    Configures the relative epoch deadline, after the current engine&#39;s
    epoch, after which WebAssembly code will trap.
    &#34;&#34;&#34;
    ffi.wasmtime_context_set_epoch_deadline(self._context, ticks_after_current)</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.set_limits"><code class="name flex">
<span>def <span class="ident">set_limits</span></span>(<span>self, memory_size: int = -1, table_elements: int = -1, instances: int = -1, tables: int = -1, memories: int = -1) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the limits of various items within this store.</p>
<ul>
<li>
<p><code>memory_size</code> - the maximum size, in bytes, that linear memory is
allowed to consume within this store. Setting this to a lower value
will cause instantiation to fail if a module needs more memory.
Additionally the <code>memory.grow</code> instruction will return -1 once this
threshold is reached.</p>
</li>
<li>
<p><code>table_elements</code> - the maximum number of elements that can be stored
within tables in this store. Currently each table element takes 8
bytes.</p>
</li>
<li>
<p><code>instances</code> - the maximum number of WebAssembly instances that can
be created.</p>
</li>
<li>
<p><code>tables</code> - the maximum number of WebAssembly tables that can
be created.</p>
</li>
<li>
<p><code>memories</code> - the maximum number of WebAssembly linear memories that
can be created.</p>
</li>
</ul>
<p>If any limit is negative then the limit will not be set as a part of
this invocation and it will be ignored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_limits(self,
               memory_size: int = -1,
               table_elements: int = -1,
               instances: int = -1,
               tables: int = -1,
               memories: int = -1) -&gt; None:
    &#34;&#34;&#34;
    Configures the limits of various items within this store.

    * `memory_size` - the maximum size, in bytes, that linear memory is
      allowed to consume within this store. Setting this to a lower value
      will cause instantiation to fail if a module needs more memory.
      Additionally the `memory.grow` instruction will return -1 once this
      threshold is reached.

    * `table_elements` - the maximum number of elements that can be stored
      within tables in this store. Currently each table element takes 8
      bytes.

    * `instances` - the maximum number of WebAssembly instances that can
      be created.

    * `tables` - the maximum number of WebAssembly tables that can
      be created.

    * `memories` - the maximum number of WebAssembly linear memories that
      can be created.

    If any limit is negative then the limit will not be set as a part of
    this invocation and it will be ignored.
    &#34;&#34;&#34;
    ffi.wasmtime_store_limiter(self._ptr, memory_size, table_elements, instances, tables, memories)</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.set_wasi"><code class="name flex">
<span>def <span class="ident">set_wasi</span></span>(<span>self, wasi: <a title="wasmtime.WasiConfig" href="#wasmtime.WasiConfig">WasiConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_wasi(self, wasi: &#34;WasiConfig&#34;) -&gt; None:
    &#34;&#34;&#34;
    TODO
    &#34;&#34;&#34;
    error = ffi.wasmtime_context_set_wasi(self._context, wasi._ptr)
    delattr(wasi, &#39;_ptr&#39;)
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>store: wasmtime._store.Store, ty: wasmtime._types.TableType, init: Union[wasmtime._value.Val, int, float, ForwardRef(None), ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new table within <code>store</code> with the specified <code>ty</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table:
    _table: ffi.wasmtime_table_t

    def __init__(self, store: Store, ty: TableType, init: IntoVal):
        &#34;&#34;&#34;
        Creates a new table within `store` with the specified `ty`.
        &#34;&#34;&#34;

        init_val = Val._convert(ty.element, init)

        table = ffi.wasmtime_table_t()
        error = ffi.wasmtime_table_new(store._context, ty._ptr, byref(init_val._unwrap_raw()), byref(table))
        if error:
            raise WasmtimeError._from_ptr(error)
        self._table = table

    @classmethod
    def _from_raw(cls, table: ffi.wasmtime_table_t) -&gt; &#34;Table&#34;:
        ty: &#34;Table&#34; = cls.__new__(cls)
        ty._table = table
        return ty

    def type(self, store: Storelike) -&gt; TableType:
        &#34;&#34;&#34;
        Gets the type of this table as a `TableType`
        &#34;&#34;&#34;

        ptr = ffi.wasmtime_table_type(store._context, byref(self._table))
        return TableType._from_ptr(ptr, None)

    def size(self, store: Storelike) -&gt; int:
        &#34;&#34;&#34;
        Gets the size, in elements, of this table
        &#34;&#34;&#34;
        return ffi.wasmtime_table_size(store._context, byref(self._table))

    def grow(self, store: Storelike, amt: int, init: IntoVal) -&gt; int:
        &#34;&#34;&#34;
        Grows this table by the specified number of slots, using the specified
        initializer for all new table slots.

        Raises a `WasmtimeError` if the table could not be grown.
        Returns the previous size of the table otherwise.
        &#34;&#34;&#34;
        init_val = Val._convert(self.type(store).element, init)
        prev = c_uint32(0)
        error = ffi.wasmtime_table_grow(store._context, byref(self._table), c_uint32(amt), byref(init_val._unwrap_raw()), byref(prev))
        if error:
            raise WasmtimeError._from_ptr(error)
        return prev.value

    def get(self, store: Store, idx: int) -&gt; Optional[Any]:
        &#34;&#34;&#34;
        Gets an individual element within this table.

        Returns `None` for null references in the table (i.e. a null `funcref`
        or a null `externref).

        Returns a `Func` for non-null `funcref` table elements.

        Returns the wrapped extern data for non-null `externref` table elements.

        Returns `None` if `idx` is out of bounds.
        &#34;&#34;&#34;
        raw = ffi.wasmtime_val_t()
        ok = ffi.wasmtime_table_get(store._context, byref(self._table), idx, byref(raw))
        if not ok:
            return None
        val = Val(raw)
        if val.value:
            return val.value
        else:
            return val

    def set(self, store: Store, idx: int, val: IntoVal) -&gt; None:
        &#34;&#34;&#34;
        Sets an individual element within this table.

        `idx` must be an integer index.

        The `val` specified must be convertible into this table&#39;s element
        type. I.e. for a `funcref` table, `val` must either be a `Func` or
        `None`, and for an `externref` table, `val` may be any arbitrary
        external data.

        Raises a `WasmtimeError` if `idx` is out of bounds.
        &#34;&#34;&#34;
        value = Val._convert(self.type(store).element, val)
        error = ffi.wasmtime_table_set(store._context, byref(self._table), idx, byref(value._unwrap_raw()))
        if error:
            raise WasmtimeError._from_ptr(error)

    def _as_extern(self) -&gt; ffi.wasmtime_extern_t:
        union = ffi.wasmtime_extern_union(table=self._table)
        return ffi.wasmtime_extern_t(ffi.WASMTIME_EXTERN_TABLE, union)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Table.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, store: wasmtime._store.Store, idx: int) ‑> Optional[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an individual element within this table.</p>
<p>Returns <code>None</code> for null references in the table (i.e. a null <code>funcref</code>
or a null `externref).</p>
<p>Returns a <code><a title="wasmtime.Func" href="#wasmtime.Func">Func</a></code> for non-null <code>funcref</code> table elements.</p>
<p>Returns the wrapped extern data for non-null <code>externref</code> table elements.</p>
<p>Returns <code>None</code> if <code>idx</code> is out of bounds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, store: Store, idx: int) -&gt; Optional[Any]:
    &#34;&#34;&#34;
    Gets an individual element within this table.

    Returns `None` for null references in the table (i.e. a null `funcref`
    or a null `externref).

    Returns a `Func` for non-null `funcref` table elements.

    Returns the wrapped extern data for non-null `externref` table elements.

    Returns `None` if `idx` is out of bounds.
    &#34;&#34;&#34;
    raw = ffi.wasmtime_val_t()
    ok = ffi.wasmtime_table_get(store._context, byref(self._table), idx, byref(raw))
    if not ok:
        return None
    val = Val(raw)
    if val.value:
        return val.value
    else:
        return val</code></pre>
</details>
</dd>
<dt id="wasmtime.Table.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')], amt: int, init: Union[wasmtime._value.Val, int, float, ForwardRef(None), ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Grows this table by the specified number of slots, using the specified
initializer for all new table slots.</p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if the table could not be grown.
Returns the previous size of the table otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grow(self, store: Storelike, amt: int, init: IntoVal) -&gt; int:
    &#34;&#34;&#34;
    Grows this table by the specified number of slots, using the specified
    initializer for all new table slots.

    Raises a `WasmtimeError` if the table could not be grown.
    Returns the previous size of the table otherwise.
    &#34;&#34;&#34;
    init_val = Val._convert(self.type(store).element, init)
    prev = c_uint32(0)
    error = ffi.wasmtime_table_grow(store._context, byref(self._table), c_uint32(amt), byref(init_val._unwrap_raw()), byref(prev))
    if error:
        raise WasmtimeError._from_ptr(error)
    return prev.value</code></pre>
</details>
</dd>
<dt id="wasmtime.Table.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, store: wasmtime._store.Store, idx: int, val: Union[wasmtime._value.Val, int, float, ForwardRef(None), ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Sets an individual element within this table.</p>
<p><code>idx</code> must be an integer index.</p>
<p>The <code>val</code> specified must be convertible into this table's element
type. I.e. for a <code>funcref</code> table, <code>val</code> must either be a <code><a title="wasmtime.Func" href="#wasmtime.Func">Func</a></code> or
<code>None</code>, and for an <code>externref</code> table, <code>val</code> may be any arbitrary
external data.</p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if <code>idx</code> is out of bounds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, store: Store, idx: int, val: IntoVal) -&gt; None:
    &#34;&#34;&#34;
    Sets an individual element within this table.

    `idx` must be an integer index.

    The `val` specified must be convertible into this table&#39;s element
    type. I.e. for a `funcref` table, `val` must either be a `Func` or
    `None`, and for an `externref` table, `val` may be any arbitrary
    external data.

    Raises a `WasmtimeError` if `idx` is out of bounds.
    &#34;&#34;&#34;
    value = Val._convert(self.type(store).element, val)
    error = ffi.wasmtime_table_set(store._context, byref(self._table), idx, byref(value._unwrap_raw()))
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Table.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the size, in elements, of this table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self, store: Storelike) -&gt; int:
    &#34;&#34;&#34;
    Gets the size, in elements, of this table
    &#34;&#34;&#34;
    return ffi.wasmtime_table_size(store._context, byref(self._table))</code></pre>
</details>
</dd>
<dt id="wasmtime.Table.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, store: Union[wasmtime._store.Store, ForwardRef('<a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a>')]) ‑> wasmtime._types.TableType</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the type of this table as a <code><a title="wasmtime.TableType" href="#wasmtime.TableType">TableType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(self, store: Storelike) -&gt; TableType:
    &#34;&#34;&#34;
    Gets the type of this table as a `TableType`
    &#34;&#34;&#34;

    ptr = ffi.wasmtime_table_type(store._context, byref(self._table))
    return TableType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.TableType"><code class="flex name class">
<span>class <span class="ident">TableType</span></span>
<span>(</span><span>valtype: wasmtime._types.ValType, limits: wasmtime._types.Limits)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableType:
    def __init__(self, valtype: ValType, limits: Limits):
        if not isinstance(limits, Limits):
            raise TypeError(&#34;expected Limits&#34;)
        type_ptr = take_owned_valtype(valtype)
        ptr = ffi.wasm_tabletype_new(type_ptr, byref(limits.__ffi__()))
        if not ptr:
            raise WasmtimeError(&#34;failed to allocate TableType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#39;ctypes._Pointer[ffi.wasm_tabletype_t]&#39;, owner: Optional[Any]) -&gt; &#34;TableType&#34;:
        ty: &#34;TableType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_tabletype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def element(self) -&gt; ValType:
        &#34;&#34;&#34;
        Returns the type of this table&#39;s elements
        &#34;&#34;&#34;
        ptr = ffi.wasm_tabletype_element(self._ptr)
        return ValType._from_ptr(ptr, self)

    @property
    def limits(self) -&gt; Limits:
        &#34;&#34;&#34;
        Returns the limits on the size of thi stable
        &#34;&#34;&#34;
        val = ffi.wasm_tabletype_limits(self._ptr)
        return Limits._from_ffi(val)

    def _as_extern(self) -&gt; &#34;ctypes._Pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_tabletype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_tabletype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.TableType.element"><code class="name">var <span class="ident">element</span> : wasmtime._types.ValType</code></dt>
<dd>
<div class="desc"><p>Returns the type of this table's elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def element(self) -&gt; ValType:
    &#34;&#34;&#34;
    Returns the type of this table&#39;s elements
    &#34;&#34;&#34;
    ptr = ffi.wasm_tabletype_element(self._ptr)
    return ValType._from_ptr(ptr, self)</code></pre>
</details>
</dd>
<dt id="wasmtime.TableType.limits"><code class="name">var <span class="ident">limits</span> : wasmtime._types.Limits</code></dt>
<dd>
<div class="desc"><p>Returns the limits on the size of thi stable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def limits(self) -&gt; Limits:
    &#34;&#34;&#34;
    Returns the limits on the size of thi stable
    &#34;&#34;&#34;
    val = ffi.wasm_tabletype_limits(self._ptr)
    return Limits._from_ffi(val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Trap"><code class="flex name class">
<span>class <span class="ident">Trap</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Creates a new trap with the given <code>message</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trap(Exception):
    _ptr: &#34;ctypes._Pointer[ffi.wasm_trap_t]&#34;

    def __init__(self, message: str):
        &#34;&#34;&#34;
        Creates a new trap with the given `message`
        &#34;&#34;&#34;

        vec = message.encode(&#39;utf-8&#39;)
        self._ptr = ffi.wasmtime_trap_new(ffi.create_string_buffer(vec), len(vec))

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasm_trap_t]&#34;) -&gt; &#34;Trap&#34;:
        if not isinstance(ptr, POINTER(ffi.wasm_trap_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        trap: Trap = cls.__new__(cls)
        trap._ptr = ptr
        return trap

    @property
    def message(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the message for this trap
        &#34;&#34;&#34;

        message = ffi.wasm_byte_vec_t()
        ffi.wasm_trap_message(self._ptr, byref(message))
        # subtract one to chop off the trailing nul byte
        message.size -= 1
        ret = ffi.to_str(message)
        message.size += 1
        ffi.wasm_byte_vec_delete(byref(message))
        return ret

    @property
    def frames(self) -&gt; List[&#34;Frame&#34;]:
        frames = FrameList(self)
        ffi.wasm_trap_trace(self._ptr, byref(frames.vec))
        ret = []
        for i in range(0, frames.vec.size):
            ret.append(Frame._from_ptr(frames.vec.data[i], frames))
        return ret

    @property
    def trap_code(self) -&gt; Optional[TrapCode]:
        &#34;&#34;&#34;
        Returns an optional `TrapCode` that corresponds to why this trap
        happened.

        Note that `None` may be returned for manually created traps which do
        not have an associated code with them.
        &#34;&#34;&#34;
        code = ffi.wasmtime_trap_code_t()
        if ffi.wasmtime_trap_code(self._ptr, byref(code)):
            return TrapCode(code.value)
        return None

    def __str__(self) -&gt; str:
        return self.message

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_trap_delete(self._ptr)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Trap.frames"><code class="name">var <span class="ident">frames</span> : List[wasmtime._trap.Frame]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frames(self) -&gt; List[&#34;Frame&#34;]:
    frames = FrameList(self)
    ffi.wasm_trap_trace(self._ptr, byref(frames.vec))
    ret = []
    for i in range(0, frames.vec.size):
        ret.append(Frame._from_ptr(frames.vec.data[i], frames))
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Trap.message"><code class="name">var <span class="ident">message</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the message for this trap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the message for this trap
    &#34;&#34;&#34;

    message = ffi.wasm_byte_vec_t()
    ffi.wasm_trap_message(self._ptr, byref(message))
    # subtract one to chop off the trailing nul byte
    message.size -= 1
    ret = ffi.to_str(message)
    message.size += 1
    ffi.wasm_byte_vec_delete(byref(message))
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Trap.trap_code"><code class="name">var <span class="ident">trap_code</span> : Optional[wasmtime._trap.TrapCode]</code></dt>
<dd>
<div class="desc"><p>Returns an optional <code><a title="wasmtime.TrapCode" href="#wasmtime.TrapCode">TrapCode</a></code> that corresponds to why this trap
happened.</p>
<p>Note that <code>None</code> may be returned for manually created traps which do
not have an associated code with them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trap_code(self) -&gt; Optional[TrapCode]:
    &#34;&#34;&#34;
    Returns an optional `TrapCode` that corresponds to why this trap
    happened.

    Note that `None` may be returned for manually created traps which do
    not have an associated code with them.
    &#34;&#34;&#34;
    code = ffi.wasmtime_trap_code_t()
    if ffi.wasmtime_trap_code(self._ptr, byref(code)):
        return TrapCode(code.value)
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.TrapCode"><code class="flex name class">
<span>class <span class="ident">TrapCode</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access::</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color.RED
&lt;Color.RED: 1&gt;
</code></pre>
<ul>
<li>value lookup:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color(1)
&lt;Color.RED: 1&gt;
</code></pre>
<ul>
<li>name lookup:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color['RED']
&lt;Color.RED: 1&gt;
</code></pre>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrapCode(Enum):
    # The current stack space was exhausted.
    STACK_OVERFLOW = 0
    # An out-of-bounds memory access.
    MEMORY_OUT_OF_BOUNDS = 1
    # A wasm atomic operation was presented with a not-naturally-aligned linear-memory address.
    HEAP_MISALIGNED = 2
    # An out-of-bounds access to a table.
    TABLE_OUT_OF_BOUNDS = 3
    # Indirect call to a null table entry.
    INDIRECT_CALL_TO_NULL = 4
    # Signature mismatch on indirect call.
    BAD_SIGNATURE = 5
    # An integer arithmetic operation caused an overflow.
    INTEGER_OVERFLOW = 6
    # An integer division by zero.
    INTEGER_DIVISION_BY_ZERO = 7
    # Failed float-to-int conversion.
    BAD_CONVERSION_TO_INTEGER = 8
    # Code that was supposed to have been unreachable was reached.
    UNREACHABLE = 9
    # Execution has potentially run too long and may be interrupted.
    INTERRUPT = 10</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="wasmtime.TrapCode.BAD_CONVERSION_TO_INTEGER"><code class="name">var <span class="ident">BAD_CONVERSION_TO_INTEGER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.BAD_SIGNATURE"><code class="name">var <span class="ident">BAD_SIGNATURE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.HEAP_MISALIGNED"><code class="name">var <span class="ident">HEAP_MISALIGNED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.INDIRECT_CALL_TO_NULL"><code class="name">var <span class="ident">INDIRECT_CALL_TO_NULL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.INTEGER_DIVISION_BY_ZERO"><code class="name">var <span class="ident">INTEGER_DIVISION_BY_ZERO</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.INTEGER_OVERFLOW"><code class="name">var <span class="ident">INTEGER_OVERFLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.INTERRUPT"><code class="name">var <span class="ident">INTERRUPT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.MEMORY_OUT_OF_BOUNDS"><code class="name">var <span class="ident">MEMORY_OUT_OF_BOUNDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.STACK_OVERFLOW"><code class="name">var <span class="ident">STACK_OVERFLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.TABLE_OUT_OF_BOUNDS"><code class="name">var <span class="ident">TABLE_OUT_OF_BOUNDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.TrapCode.UNREACHABLE"><code class="name">var <span class="ident">UNREACHABLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="wasmtime.Val"><code class="flex name class">
<span>class <span class="ident">Val</span></span>
<span>(</span><span>raw: wasmtime._bindings.wasmtime_val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Val:
    # We can&#39;t let the extern values we wrap `externref`s around be GC&#39;d, so we
    # pin them in `_id_to_extern`. Additionally, we might make multiple
    # `externref`s to the same extern value, so we count how many references
    # we&#39;ve created in `_id_to_ref_count`, and only remove a value&#39;s entry from
    # `_id_to_extern` once the ref count is zero.
    _id_to_extern: typing.Dict[int, typing.Any] = {}
    _id_to_ref_count: typing.Dict[int, int] = {}

    _raw: typing.Optional[wasmtime_val_t]

    @classmethod
    def i32(cls, val: int) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 32-bit integer value
        &#34;&#34;&#34;
        if not isinstance(val, int):
            raise TypeError(&#34;expected an integer&#34;)
        ffi = wasmtime_val_t(WASMTIME_I32, wasmtime_valunion(i32=val))
        return Val(ffi)

    @classmethod
    def i64(cls, val: int) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 64-bit integer value
        &#34;&#34;&#34;
        if not isinstance(val, int):
            raise TypeError(&#34;expected an integer&#34;)
        ffi = wasmtime_val_t(WASMTIME_I64, wasmtime_valunion(i64=val))
        return Val(ffi)

    @classmethod
    def f32(cls, val: float) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 32-bit float value
        &#34;&#34;&#34;
        if not isinstance(val, float):
            raise TypeError(&#34;expected a float&#34;)
        ffi = wasmtime_val_t(WASMTIME_F32, wasmtime_valunion(f32=val))
        return Val(ffi)

    @classmethod
    def f64(cls, val: float) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 64-bit float value
        &#34;&#34;&#34;
        if not isinstance(val, float):
            raise TypeError(&#34;expected a float&#34;)
        ffi = wasmtime_val_t(WASMTIME_F64, wasmtime_valunion(f64=val))
        return Val(ffi)

    @classmethod
    def externref(cls, extern: typing.Optional[typing.Any]) -&gt; &#34;Val&#34;:
        ffi = wasmtime_val_t(WASMTIME_EXTERNREF)
        ffi.of.externref = POINTER(wasmtime_externref_t)()
        if extern is not None:
            extern_id = _intern(extern)
            ptr = wasmtime_externref_new(extern_id, _externref_finalizer)
            ffi.of.externref = ptr
        return Val(ffi)

    @classmethod
    def funcref(cls, f: &#34;typing.Optional[wasmtime.Func]&#34;) -&gt; &#34;Val&#34;:
        ffi = wasmtime_val_t(WASMTIME_FUNCREF)
        if f:
            ffi.of.funcref = f._func
        return Val(ffi)

    @classmethod
    def ref_null(cls, ty: ValType) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a null reference value of the given type.

        Raise an exception if `ty` is not a reference type.
        &#34;&#34;&#34;
        if ty == ValType.externref():
            return Val.externref(None)
        if ty == ValType.funcref():
            return Val.funcref(None)
        raise WasmtimeError(&#34;Invalid reference type for `ref_null`: %s&#34; % ty)

    def __init__(self, raw: wasmtime_val_t):
        self._raw = raw

    def __eq__(self, rhs: typing.Any) -&gt; typing.Any:
        if isinstance(rhs, Val):
            return self._unwrap_raw().kind == rhs._unwrap_raw().kind and self.value == rhs.value
        return self.value == rhs

    def __del__(self) -&gt; None:
        if hasattr(self, &#34;_raw&#34;) and self._raw is not None:
            wasmtime_val_delete(ctypes.byref(self._raw))

    def _clone(self) -&gt; &#34;Val&#34;:
        raw = self._unwrap_raw()
        if raw.kind == WASMTIME_EXTERNREF and raw.of.externref:
            externref = wasmtime_externref_clone(raw.of.externref)
            raw = wasmtime_val_t(WASMTIME_EXTERNREF)
            raw.of.externref = externref
        return Val(raw)

    @classmethod
    def _convert(cls, ty: ValType, val: &#34;IntoVal&#34;) -&gt; &#34;Val&#34;:
        if isinstance(val, Val):
            if ty != val.type:
                raise TypeError(&#34;wrong type of `Val` provided&#34;)
            return val
        elif isinstance(val, int):
            if ty == ValType.i32():
                return Val.i32(val)
            if ty == ValType.i64():
                return Val.i64(val)
        elif isinstance(val, float):
            if ty == ValType.f32():
                return Val.f32(val)
            if ty == ValType.f64():
                return Val.f64(val)
        elif isinstance(val, wasmtime.Func):
            return Val.funcref(val)
        elif val is None:
            if ty == ValType.externref():
                return Val.externref(None)
            if ty == ValType.funcref():
                return Val.funcref(None)
        elif ty == ValType.externref():
            return Val.externref(val)
        raise TypeError(&#34;don&#39;t know how to convert %r to %s&#34; % (val, ty))

    def _into_raw(self) -&gt; wasmtime_val_t:
        raw = self._unwrap_raw()
        self._raw = None
        return raw

    def _unwrap_raw(self) -&gt; wasmtime_val_t:
        if isinstance(self._raw, wasmtime_val_t):
            return self._raw
        else:
            raise WasmtimeError(&#34;use of moved `Val`&#34;)

    @classmethod
    def _value(cls, raw: wasmtime_val_t) -&gt; typing.Union[int, float, &#34;wasmtime.Func&#34;, typing.Any]:
        if raw.kind == WASMTIME_I32.value:
            return raw.of.i32
        if raw.kind == WASMTIME_I64.value:
            return raw.of.i64
        if raw.kind == WASMTIME_F32.value:
            return raw.of.f32
        if raw.kind == WASMTIME_F64.value:
            return raw.of.f64
        if raw.kind == WASMTIME_EXTERNREF.value:
            return Val._as_externref(raw)
        if raw.kind == WASMTIME_FUNCREF.value:
            return Val._as_funcref(raw)
        raise WasmtimeError(&#34;Unkown `wasmtime_valkind_t`: {}&#34;.format(raw.kind))

    @property
    def value(self) -&gt; typing.Union[int, float, &#34;wasmtime.Func&#34;, typing.Any]:
        &#34;&#34;&#34;
        Get the the underlying value as a python value

        Returns `None` if the value can&#39;t be represented in Python, or if the
        value is a null reference type.
        &#34;&#34;&#34;
        return Val._value(self._unwrap_raw())

    def as_i32(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;
        Get the 32-bit integer value of this value, or `None` if it&#39;s not an i32
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASMTIME_I32.value:
            return int(raw.of.i32)
        else:
            return None

    def as_i64(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;
        Get the 64-bit integer value of this value, or `None` if it&#39;s not an i64
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASM_I64.value:
            return raw.of.i64
        else:
            return None

    def as_f32(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Get the 32-bit float value of this value, or `None` if it&#39;s not an f32
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASMTIME_F32.value:
            return raw.of.f32
        else:
            return None

    def as_f64(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Get the 64-bit float value of this value, or `None` if it&#39;s not an f64
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASMTIME_F64.value:
            return raw.of.f64
        else:
            return None

    @classmethod
    def _as_externref(cls, raw: wasmtime_val_t) -&gt; typing.Optional[typing.Any]:
        if raw.kind != WASMTIME_EXTERNREF.value:
            return None
        if not raw.of.externref:
            return None
        extern_id = wasmtime_externref_data(raw.of.externref)
        return _unintern(extern_id)

    def as_externref(self) -&gt; typing.Optional[typing.Any]:
        &#34;&#34;&#34;
        Get the extern data referenced by this `externref` value, or `None` if
        it&#39;s not an `externref`.
        &#34;&#34;&#34;
        return Val._as_externref(self._unwrap_raw())

    @classmethod
    def _as_funcref(cls, raw: wasmtime_val_t) -&gt; typing.Optional[&#34;wasmtime.Func&#34;]:
        if raw.kind != WASMTIME_FUNCREF.value:
            return None
        if raw.of.funcref.store_id == 0:
            return None
        else:
            return wasmtime.Func._from_raw(raw.of.funcref)

    def as_funcref(self) -&gt; typing.Optional[&#34;wasmtime.Func&#34;]:
        &#34;&#34;&#34;
        Get the function that this `funcref` value is referencing, or `None` if
        this is not a `funcref` value, or is a null reference.
        &#34;&#34;&#34;
        return Val._as_funcref(self._unwrap_raw())

    @property
    def type(self) -&gt; ValType:
        &#34;&#34;&#34;
        Returns the `ValType` corresponding to this `Val`
        &#34;&#34;&#34;
        kind = self._unwrap_raw().kind
        if kind == WASMTIME_I32.value:
            return ValType.i32()
        elif kind == WASMTIME_I64.value:
            return ValType.i64()
        elif kind == WASMTIME_F32.value:
            return ValType.f32()
        elif kind == WASMTIME_F64.value:
            return ValType.f64()
        elif kind == WASMTIME_V128.value:
            raise Exception(&#34;unimplemented v128 type&#34;)
        elif kind == WASMTIME_EXTERNREF.value:
            return ValType.externref()
        elif kind == WASMTIME_FUNCREF.value:
            return ValType.funcref()
        else:
            raise Exception(&#34;unknown kind %d&#34; % kind.value)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="wasmtime.Val.externref"><code class="name flex">
<span>def <span class="ident">externref</span></span>(<span>extern: Optional[Any]) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def externref(cls, extern: typing.Optional[typing.Any]) -&gt; &#34;Val&#34;:
    ffi = wasmtime_val_t(WASMTIME_EXTERNREF)
    ffi.of.externref = POINTER(wasmtime_externref_t)()
    if extern is not None:
        extern_id = _intern(extern)
        ptr = wasmtime_externref_new(extern_id, _externref_finalizer)
        ffi.of.externref = ptr
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.f32"><code class="name flex">
<span>def <span class="ident">f32</span></span>(<span>val: float) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 32-bit float value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f32(cls, val: float) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 32-bit float value
    &#34;&#34;&#34;
    if not isinstance(val, float):
        raise TypeError(&#34;expected a float&#34;)
    ffi = wasmtime_val_t(WASMTIME_F32, wasmtime_valunion(f32=val))
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.f64"><code class="name flex">
<span>def <span class="ident">f64</span></span>(<span>val: float) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 64-bit float value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f64(cls, val: float) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 64-bit float value
    &#34;&#34;&#34;
    if not isinstance(val, float):
        raise TypeError(&#34;expected a float&#34;)
    ffi = wasmtime_val_t(WASMTIME_F64, wasmtime_valunion(f64=val))
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.funcref"><code class="name flex">
<span>def <span class="ident">funcref</span></span>(<span>f: typing.Optional[<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>]) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def funcref(cls, f: &#34;typing.Optional[wasmtime.Func]&#34;) -&gt; &#34;Val&#34;:
    ffi = wasmtime_val_t(WASMTIME_FUNCREF)
    if f:
        ffi.of.funcref = f._func
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.i32"><code class="name flex">
<span>def <span class="ident">i32</span></span>(<span>val: int) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 32-bit integer value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i32(cls, val: int) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 32-bit integer value
    &#34;&#34;&#34;
    if not isinstance(val, int):
        raise TypeError(&#34;expected an integer&#34;)
    ffi = wasmtime_val_t(WASMTIME_I32, wasmtime_valunion(i32=val))
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.i64"><code class="name flex">
<span>def <span class="ident">i64</span></span>(<span>val: int) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 64-bit integer value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i64(cls, val: int) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 64-bit integer value
    &#34;&#34;&#34;
    if not isinstance(val, int):
        raise TypeError(&#34;expected an integer&#34;)
    ffi = wasmtime_val_t(WASMTIME_I64, wasmtime_valunion(i64=val))
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.ref_null"><code class="name flex">
<span>def <span class="ident">ref_null</span></span>(<span>ty: wasmtime._types.ValType) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a null reference value of the given type.</p>
<p>Raise an exception if <code>ty</code> is not a reference type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ref_null(cls, ty: ValType) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a null reference value of the given type.

    Raise an exception if `ty` is not a reference type.
    &#34;&#34;&#34;
    if ty == ValType.externref():
        return Val.externref(None)
    if ty == ValType.funcref():
        return Val.funcref(None)
    raise WasmtimeError(&#34;Invalid reference type for `ref_null`: %s&#34; % ty)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Val.type"><code class="name">var <span class="ident">type</span> : wasmtime._types.ValType</code></dt>
<dd>
<div class="desc"><p>Returns the <code><a title="wasmtime.ValType" href="#wasmtime.ValType">ValType</a></code> corresponding to this <code><a title="wasmtime.Val" href="#wasmtime.Val">Val</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; ValType:
    &#34;&#34;&#34;
    Returns the `ValType` corresponding to this `Val`
    &#34;&#34;&#34;
    kind = self._unwrap_raw().kind
    if kind == WASMTIME_I32.value:
        return ValType.i32()
    elif kind == WASMTIME_I64.value:
        return ValType.i64()
    elif kind == WASMTIME_F32.value:
        return ValType.f32()
    elif kind == WASMTIME_F64.value:
        return ValType.f64()
    elif kind == WASMTIME_V128.value:
        raise Exception(&#34;unimplemented v128 type&#34;)
    elif kind == WASMTIME_EXTERNREF.value:
        return ValType.externref()
    elif kind == WASMTIME_FUNCREF.value:
        return ValType.funcref()
    else:
        raise Exception(&#34;unknown kind %d&#34; % kind.value)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.value"><code class="name">var <span class="ident">value</span> : Union[int, float, wasmtime._func.Func, Any]</code></dt>
<dd>
<div class="desc"><p>Get the the underlying value as a python value</p>
<p>Returns <code>None</code> if the value can't be represented in Python, or if the
value is a null reference type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; typing.Union[int, float, &#34;wasmtime.Func&#34;, typing.Any]:
    &#34;&#34;&#34;
    Get the the underlying value as a python value

    Returns `None` if the value can&#39;t be represented in Python, or if the
    value is a null reference type.
    &#34;&#34;&#34;
    return Val._value(self._unwrap_raw())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Val.as_externref"><code class="name flex">
<span>def <span class="ident">as_externref</span></span>(<span>self) ‑> Optional[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the extern data referenced by this <code>externref</code> value, or <code>None</code> if
it's not an <code>externref</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_externref(self) -&gt; typing.Optional[typing.Any]:
    &#34;&#34;&#34;
    Get the extern data referenced by this `externref` value, or `None` if
    it&#39;s not an `externref`.
    &#34;&#34;&#34;
    return Val._as_externref(self._unwrap_raw())</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_f32"><code class="name flex">
<span>def <span class="ident">as_f32</span></span>(<span>self) ‑> Optional[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 32-bit float value of this value, or <code>None</code> if it's not an f32</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_f32(self) -&gt; typing.Optional[float]:
    &#34;&#34;&#34;
    Get the 32-bit float value of this value, or `None` if it&#39;s not an f32
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASMTIME_F32.value:
        return raw.of.f32
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_f64"><code class="name flex">
<span>def <span class="ident">as_f64</span></span>(<span>self) ‑> Optional[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 64-bit float value of this value, or <code>None</code> if it's not an f64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_f64(self) -&gt; typing.Optional[float]:
    &#34;&#34;&#34;
    Get the 64-bit float value of this value, or `None` if it&#39;s not an f64
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASMTIME_F64.value:
        return raw.of.f64
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_funcref"><code class="name flex">
<span>def <span class="ident">as_funcref</span></span>(<span>self) ‑> Optional[wasmtime._func.Func]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the function that this <code>funcref</code> value is referencing, or <code>None</code> if
this is not a <code>funcref</code> value, or is a null reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_funcref(self) -&gt; typing.Optional[&#34;wasmtime.Func&#34;]:
    &#34;&#34;&#34;
    Get the function that this `funcref` value is referencing, or `None` if
    this is not a `funcref` value, or is a null reference.
    &#34;&#34;&#34;
    return Val._as_funcref(self._unwrap_raw())</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_i32"><code class="name flex">
<span>def <span class="ident">as_i32</span></span>(<span>self) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 32-bit integer value of this value, or <code>None</code> if it's not an i32</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_i32(self) -&gt; typing.Optional[int]:
    &#34;&#34;&#34;
    Get the 32-bit integer value of this value, or `None` if it&#39;s not an i32
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASMTIME_I32.value:
        return int(raw.of.i32)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_i64"><code class="name flex">
<span>def <span class="ident">as_i64</span></span>(<span>self) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 64-bit integer value of this value, or <code>None</code> if it's not an i64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_i64(self) -&gt; typing.Optional[int]:
    &#34;&#34;&#34;
    Get the 64-bit integer value of this value, or `None` if it&#39;s not an i64
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASM_I64.value:
        return raw.of.i64
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.ValType"><code class="flex name class">
<span>class <span class="ident">ValType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValType:
    _ptr: &#34;ctypes._Pointer[ffi.wasm_valtype_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def i32(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_I32)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def i64(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_I64)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def f32(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_F32)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def f64(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_F64)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def externref(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_ANYREF)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def funcref(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_FUNCREF)
        return ValType._from_ptr(ptr, None)

    def __init__(self) -&gt; None:
        raise WasmtimeError(&#34;cannot construct directly&#34;)

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer[ffi.wasm_valtype_t]&#34;, owner: Optional[Any]) -&gt; &#34;ValType&#34;:
        ty: &#34;ValType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_valtype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, ValType):
            return False
        assert(self._ptr is not None)
        assert(other._ptr is not None)
        kind1 = ffi.wasm_valtype_kind(self._ptr)
        kind2 = ffi.wasm_valtype_kind(other._ptr)
        return kind1 == kind2

    def __ne__(self, other: object) -&gt; bool:
        return not self.__eq__(other)

    def __repr__(self) -&gt; str:
        return str(self)

    def __str__(self) -&gt; str:
        assert(self._ptr is not None)
        kind = ffi.wasm_valtype_kind(self._ptr)
        if kind == ffi.WASM_I32.value:
            return &#39;i32&#39;
        if kind == ffi.WASM_I64.value:
            return &#39;i64&#39;
        if kind == ffi.WASM_F32.value:
            return &#39;f32&#39;
        if kind == ffi.WASM_F64.value:
            return &#39;f64&#39;
        if kind == ffi.WASM_ANYREF.value:
            return &#39;anyref&#39;
        if kind == ffi.WASM_FUNCREF.value:
            return &#39;funcref&#39;
        return &#39;ValType(%d)&#39; % kind.value

    def __del__(self) -&gt; None:
        if not hasattr(self, &#39;_owner&#39;) or not hasattr(self, &#39;_ptr&#39;):
            return
        # If this is owned by another object we don&#39;t free it since that object
        # is responsible for freeing the backing memory.
        if self._owner is None:
            ffi.wasm_valtype_delete(self._ptr)

    @classmethod
    def _from_list(cls, items: &#34;ctypes._Pointer[ffi.wasm_valtype_vec_t]&#34;, owner: Optional[Any]) -&gt; List[&#34;ValType&#34;]:
        types = []
        for i in range(0, items.contents.size):
            types.append(ValType._from_ptr(items.contents.data[i], owner))
        return types</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="wasmtime.ValType.externref"><code class="name flex">
<span>def <span class="ident">externref</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def externref(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_ANYREF)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.f32"><code class="name flex">
<span>def <span class="ident">f32</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f32(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_F32)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.f64"><code class="name flex">
<span>def <span class="ident">f64</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f64(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_F64)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.funcref"><code class="name flex">
<span>def <span class="ident">funcref</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def funcref(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_FUNCREF)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.i32"><code class="name flex">
<span>def <span class="ident">i32</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i32(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_I32)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.i64"><code class="name flex">
<span>def <span class="ident">i64</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i64(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_I64)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.WasiConfig"><code class="flex name class">
<span>class <span class="ident">WasiConfig</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WasiConfig:
    def __init__(self) -&gt; None:
        self._ptr = ffi.wasi_config_new()

    @setter_property
    def argv(self, argv: List[str]) -&gt; None:
        &#34;&#34;&#34;
        Explicitly configure the `argv` for this WASI configuration
        &#34;&#34;&#34;
        ptrs = to_char_array(argv)
        ffi.wasi_config_set_argv(self._ptr, c_int(len(argv)), ptrs)

    def inherit_argv(self) -&gt; None:
        ffi.wasi_config_inherit_argv(self._ptr)

    @setter_property
    def env(self, pairs: Iterable[Iterable]) -&gt; None:
        &#34;&#34;&#34;
        Configure environment variables to be returned for this WASI
        configuration.

        The `pairs` provided must be an iterable list of key/value pairs of
        environment variables.
        &#34;&#34;&#34;
        names = []
        values = []
        for name, value in pairs:
            names.append(name)
            values.append(value)
        name_ptrs = to_char_array(names)
        value_ptrs = to_char_array(values)
        ffi.wasi_config_set_env(self._ptr, c_int(
            len(names)), name_ptrs, value_ptrs)

    def inherit_env(self) -&gt; None:
        &#34;&#34;&#34;
        Configures the environment variables available within WASI to be those
        in this own process&#39;s environment. All environment variables are
        inherited.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_env(self._ptr)

    @setter_property
    def stdin_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Configures a file to be used as the stdin stream of this WASI
        configuration.

        Reads of the stdin stream will read the path specified.

        The file must already exist on the filesystem. If it cannot be
        opened then `WasmtimeError` is raised.
        &#34;&#34;&#34;
        res = ffi.wasi_config_set_stdin_file(
            self._ptr, c_char_p(path.encode(&#39;utf-8&#39;)))
        if not res:
            raise WasmtimeError(&#34;failed to set stdin file&#34;)

    def inherit_stdin(self) -&gt; None:
        &#34;&#34;&#34;
        Configures this own process&#39;s stdin to be used as the WASI program&#39;s
        stdin.

        Reads of the stdin stream will read this process&#39;s stdin.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_stdin(self._ptr)

    @setter_property
    def stdout_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Configures a file to be used as the stdout stream of this WASI
        configuration.

        Writes to stdout will be written to the file specified.

        The file specified will be created if it doesn&#39;t exist, or truncated if
        it already exists. It must be available to open for writing. If it
        cannot be opened for writing then `WasmtimeError` is raised.
        &#34;&#34;&#34;
        res = ffi.wasi_config_set_stdout_file(
            self._ptr, c_char_p(path.encode(&#39;utf-8&#39;)))
        if not res:
            raise WasmtimeError(&#34;failed to set stdout file&#34;)

    def inherit_stdout(self) -&gt; None:
        &#34;&#34;&#34;
        Configures this own process&#39;s stdout to be used as the WASI program&#39;s
        stdout.

        Writes to stdout stream will write to this process&#39;s stdout.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_stdout(self._ptr)

    @setter_property
    def stderr_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Configures a file to be used as the stderr stream of this WASI
        configuration.

        Writes to stderr will be written to the file specified.

        The file specified will be created if it doesn&#39;t exist, or truncated if
        it already exists. It must be available to open for writing. If it
        cannot be opened for writing then `WasmtimeError` is raised.
        &#34;&#34;&#34;
        res = ffi.wasi_config_set_stderr_file(
            self._ptr, c_char_p(path.encode(&#39;utf-8&#39;)))
        if not res:
            raise WasmtimeError(&#34;failed to set stderr file&#34;)

    def inherit_stderr(self) -&gt; None:
        &#34;&#34;&#34;
        Configures this own process&#39;s stderr to be used as the WASI program&#39;s
        stderr.

        Writes to stderr stream will write to this process&#39;s stderr.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_stderr(self._ptr)

    def preopen_dir(self, path: str, guest_path: str) -&gt; None:
        path_ptr = c_char_p(path.encode(&#39;utf-8&#39;))
        guest_path_ptr = c_char_p(guest_path.encode(&#39;utf-8&#39;))
        ffi.wasi_config_preopen_dir(self._ptr, path_ptr, guest_path_ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasi_config_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.WasiConfig.argv"><code class="name">var <span class="ident">argv</span></code></dt>
<dd>
<div class="desc"><p>Explicitly configure the <code>argv</code> for this WASI configuration</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.env"><code class="name">var <span class="ident">env</span></code></dt>
<dd>
<div class="desc"><p>Configure environment variables to be returned for this WASI
configuration.</p>
<p>The <code>pairs</code> provided must be an iterable list of key/value pairs of
environment variables.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.stderr_file"><code class="name">var <span class="ident">stderr_file</span></code></dt>
<dd>
<div class="desc"><p>Configures a file to be used as the stderr stream of this WASI
configuration.</p>
<p>Writes to stderr will be written to the file specified.</p>
<p>The file specified will be created if it doesn't exist, or truncated if
it already exists. It must be available to open for writing. If it
cannot be opened for writing then <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> is raised.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.stdin_file"><code class="name">var <span class="ident">stdin_file</span></code></dt>
<dd>
<div class="desc"><p>Configures a file to be used as the stdin stream of this WASI
configuration.</p>
<p>Reads of the stdin stream will read the path specified.</p>
<p>The file must already exist on the filesystem. If it cannot be
opened then <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> is raised.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.stdout_file"><code class="name">var <span class="ident">stdout_file</span></code></dt>
<dd>
<div class="desc"><p>Configures a file to be used as the stdout stream of this WASI
configuration.</p>
<p>Writes to stdout will be written to the file specified.</p>
<p>The file specified will be created if it doesn't exist, or truncated if
it already exists. It must be available to open for writing. If it
cannot be opened for writing then <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> is raised.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.WasiConfig.inherit_argv"><code class="name flex">
<span>def <span class="ident">inherit_argv</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_argv(self) -&gt; None:
    ffi.wasi_config_inherit_argv(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_env"><code class="name flex">
<span>def <span class="ident">inherit_env</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the environment variables available within WASI to be those
in this own process's environment. All environment variables are
inherited.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_env(self) -&gt; None:
    &#34;&#34;&#34;
    Configures the environment variables available within WASI to be those
    in this own process&#39;s environment. All environment variables are
    inherited.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_env(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_stderr"><code class="name flex">
<span>def <span class="ident">inherit_stderr</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures this own process's stderr to be used as the WASI program's
stderr.</p>
<p>Writes to stderr stream will write to this process's stderr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_stderr(self) -&gt; None:
    &#34;&#34;&#34;
    Configures this own process&#39;s stderr to be used as the WASI program&#39;s
    stderr.

    Writes to stderr stream will write to this process&#39;s stderr.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_stderr(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_stdin"><code class="name flex">
<span>def <span class="ident">inherit_stdin</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures this own process's stdin to be used as the WASI program's
stdin.</p>
<p>Reads of the stdin stream will read this process's stdin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_stdin(self) -&gt; None:
    &#34;&#34;&#34;
    Configures this own process&#39;s stdin to be used as the WASI program&#39;s
    stdin.

    Reads of the stdin stream will read this process&#39;s stdin.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_stdin(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_stdout"><code class="name flex">
<span>def <span class="ident">inherit_stdout</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures this own process's stdout to be used as the WASI program's
stdout.</p>
<p>Writes to stdout stream will write to this process's stdout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_stdout(self) -&gt; None:
    &#34;&#34;&#34;
    Configures this own process&#39;s stdout to be used as the WASI program&#39;s
    stdout.

    Writes to stdout stream will write to this process&#39;s stdout.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_stdout(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.preopen_dir"><code class="name flex">
<span>def <span class="ident">preopen_dir</span></span>(<span>self, path: str, guest_path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preopen_dir(self, path: str, guest_path: str) -&gt; None:
    path_ptr = c_char_p(path.encode(&#39;utf-8&#39;))
    guest_path_ptr = c_char_p(guest_path.encode(&#39;utf-8&#39;))
    ffi.wasi_config_preopen_dir(self._ptr, path_ptr, guest_path_ptr)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.WasmtimeError"><code class="flex name class">
<span>class <span class="ident">WasmtimeError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WasmtimeError(Exception):
    _ptr: &#34;Optional[ctypes._Pointer[ffi.wasmtime_error_t]]&#34;
    _message: Optional[str]

    def __init__(self, message: str):
        self._message = message
        self._ptr = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;ctypes._Pointer&#34;) -&gt; &#39;WasmtimeError&#39;:
        from . import _ffi as ffi
        if not isinstance(ptr, POINTER(ffi.wasmtime_error_t)):
            raise TypeError(&#34;wrong pointer type&#34;)

        exit_code = c_int(0)
        if ffi.wasmtime_error_exit_status(ptr, byref(exit_code)):
            exit_trap: ExitTrap = ExitTrap.__new__(ExitTrap)
            exit_trap._ptr = ptr
            exit_trap.code = exit_code.value
            return exit_trap

        err: WasmtimeError = cls.__new__(cls)
        err._ptr = ptr
        err._message = None
        return err

    def __str__(self) -&gt; str:
        if self._message:
            return self._message
        message_vec = ffi.wasm_byte_vec_t()
        ffi.wasmtime_error_message(self._ptr, byref(message_vec))
        message = ffi.to_str(message_vec)
        ffi.wasm_byte_vec_delete(byref(message_vec))
        return message

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;) and self._ptr:
            ffi.wasmtime_error_delete(self._ptr)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>wasmtime._error.ExitTrap</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="wasmtime.bindgen" href="bindgen/index.html">wasmtime.bindgen</a></code></li>
<li><code><a title="wasmtime.loader" href="loader.html">wasmtime.loader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wasmtime.wat2wasm" href="#wasmtime.wat2wasm">wat2wasm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Caller.get" href="#wasmtime.Caller.get">get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Config" href="#wasmtime.Config">Config</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Config.cache" href="#wasmtime.Config.cache">cache</a></code></li>
<li><code><a title="wasmtime.Config.consume_fuel" href="#wasmtime.Config.consume_fuel">consume_fuel</a></code></li>
<li><code><a title="wasmtime.Config.cranelift_debug_verifier" href="#wasmtime.Config.cranelift_debug_verifier">cranelift_debug_verifier</a></code></li>
<li><code><a title="wasmtime.Config.cranelift_opt_level" href="#wasmtime.Config.cranelift_opt_level">cranelift_opt_level</a></code></li>
<li><code><a title="wasmtime.Config.debug_info" href="#wasmtime.Config.debug_info">debug_info</a></code></li>
<li><code><a title="wasmtime.Config.epoch_interruption" href="#wasmtime.Config.epoch_interruption">epoch_interruption</a></code></li>
<li><code><a title="wasmtime.Config.parallel_compilation" href="#wasmtime.Config.parallel_compilation">parallel_compilation</a></code></li>
<li><code><a title="wasmtime.Config.profiler" href="#wasmtime.Config.profiler">profiler</a></code></li>
<li><code><a title="wasmtime.Config.strategy" href="#wasmtime.Config.strategy">strategy</a></code></li>
<li><code><a title="wasmtime.Config.wasm_bulk_memory" href="#wasmtime.Config.wasm_bulk_memory">wasm_bulk_memory</a></code></li>
<li><code><a title="wasmtime.Config.wasm_memory64" href="#wasmtime.Config.wasm_memory64">wasm_memory64</a></code></li>
<li><code><a title="wasmtime.Config.wasm_multi_memory" href="#wasmtime.Config.wasm_multi_memory">wasm_multi_memory</a></code></li>
<li><code><a title="wasmtime.Config.wasm_multi_value" href="#wasmtime.Config.wasm_multi_value">wasm_multi_value</a></code></li>
<li><code><a title="wasmtime.Config.wasm_reference_types" href="#wasmtime.Config.wasm_reference_types">wasm_reference_types</a></code></li>
<li><code><a title="wasmtime.Config.wasm_simd" href="#wasmtime.Config.wasm_simd">wasm_simd</a></code></li>
<li><code><a title="wasmtime.Config.wasm_threads" href="#wasmtime.Config.wasm_threads">wasm_threads</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Engine" href="#wasmtime.Engine">Engine</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Engine.increment_epoch" href="#wasmtime.Engine.increment_epoch">increment_epoch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.ExitTrap" href="#wasmtime.ExitTrap">ExitTrap</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.ExitTrap.code" href="#wasmtime.ExitTrap.code">code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.ExportType" href="#wasmtime.ExportType">ExportType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.ExportType.name" href="#wasmtime.ExportType.name">name</a></code></li>
<li><code><a title="wasmtime.ExportType.type" href="#wasmtime.ExportType.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Frame" href="#wasmtime.Frame">Frame</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Frame.func_index" href="#wasmtime.Frame.func_index">func_index</a></code></li>
<li><code><a title="wasmtime.Frame.func_name" href="#wasmtime.Frame.func_name">func_name</a></code></li>
<li><code><a title="wasmtime.Frame.func_offset" href="#wasmtime.Frame.func_offset">func_offset</a></code></li>
<li><code><a title="wasmtime.Frame.module_name" href="#wasmtime.Frame.module_name">module_name</a></code></li>
<li><code><a title="wasmtime.Frame.module_offset" href="#wasmtime.Frame.module_offset">module_offset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Func" href="#wasmtime.Func">Func</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Func.type" href="#wasmtime.Func.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.FuncType" href="#wasmtime.FuncType">FuncType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.FuncType.params" href="#wasmtime.FuncType.params">params</a></code></li>
<li><code><a title="wasmtime.FuncType.results" href="#wasmtime.FuncType.results">results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Global" href="#wasmtime.Global">Global</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Global.set_value" href="#wasmtime.Global.set_value">set_value</a></code></li>
<li><code><a title="wasmtime.Global.type" href="#wasmtime.Global.type">type</a></code></li>
<li><code><a title="wasmtime.Global.value" href="#wasmtime.Global.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.GlobalType" href="#wasmtime.GlobalType">GlobalType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.GlobalType.content" href="#wasmtime.GlobalType.content">content</a></code></li>
<li><code><a title="wasmtime.GlobalType.mutable" href="#wasmtime.GlobalType.mutable">mutable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.ImportType" href="#wasmtime.ImportType">ImportType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.ImportType.module" href="#wasmtime.ImportType.module">module</a></code></li>
<li><code><a title="wasmtime.ImportType.name" href="#wasmtime.ImportType.name">name</a></code></li>
<li><code><a title="wasmtime.ImportType.type" href="#wasmtime.ImportType.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Instance" href="#wasmtime.Instance">Instance</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Instance.exports" href="#wasmtime.Instance.exports">exports</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Limits" href="#wasmtime.Limits">Limits</a></code></h4>
</li>
<li>
<h4><code><a title="wasmtime.Linker" href="#wasmtime.Linker">Linker</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.Linker.allow_shadowing" href="#wasmtime.Linker.allow_shadowing">allow_shadowing</a></code></li>
<li><code><a title="wasmtime.Linker.define" href="#wasmtime.Linker.define">define</a></code></li>
<li><code><a title="wasmtime.Linker.define_func" href="#wasmtime.Linker.define_func">define_func</a></code></li>
<li><code><a title="wasmtime.Linker.define_instance" href="#wasmtime.Linker.define_instance">define_instance</a></code></li>
<li><code><a title="wasmtime.Linker.define_module" href="#wasmtime.Linker.define_module">define_module</a></code></li>
<li><code><a title="wasmtime.Linker.define_wasi" href="#wasmtime.Linker.define_wasi">define_wasi</a></code></li>
<li><code><a title="wasmtime.Linker.engine" href="#wasmtime.Linker.engine">engine</a></code></li>
<li><code><a title="wasmtime.Linker.get" href="#wasmtime.Linker.get">get</a></code></li>
<li><code><a title="wasmtime.Linker.get_default" href="#wasmtime.Linker.get_default">get_default</a></code></li>
<li><code><a title="wasmtime.Linker.instantiate" href="#wasmtime.Linker.instantiate">instantiate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.Memory.data_len" href="#wasmtime.Memory.data_len">data_len</a></code></li>
<li><code><a title="wasmtime.Memory.data_ptr" href="#wasmtime.Memory.data_ptr">data_ptr</a></code></li>
<li><code><a title="wasmtime.Memory.get_buffer_ptr" href="#wasmtime.Memory.get_buffer_ptr">get_buffer_ptr</a></code></li>
<li><code><a title="wasmtime.Memory.grow" href="#wasmtime.Memory.grow">grow</a></code></li>
<li><code><a title="wasmtime.Memory.read" href="#wasmtime.Memory.read">read</a></code></li>
<li><code><a title="wasmtime.Memory.size" href="#wasmtime.Memory.size">size</a></code></li>
<li><code><a title="wasmtime.Memory.type" href="#wasmtime.Memory.type">type</a></code></li>
<li><code><a title="wasmtime.Memory.write" href="#wasmtime.Memory.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.MemoryType" href="#wasmtime.MemoryType">MemoryType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.MemoryType.is_64" href="#wasmtime.MemoryType.is_64">is_64</a></code></li>
<li><code><a title="wasmtime.MemoryType.limits" href="#wasmtime.MemoryType.limits">limits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.Module.deserialize" href="#wasmtime.Module.deserialize">deserialize</a></code></li>
<li><code><a title="wasmtime.Module.deserialize_file" href="#wasmtime.Module.deserialize_file">deserialize_file</a></code></li>
<li><code><a title="wasmtime.Module.exports" href="#wasmtime.Module.exports">exports</a></code></li>
<li><code><a title="wasmtime.Module.from_file" href="#wasmtime.Module.from_file">from_file</a></code></li>
<li><code><a title="wasmtime.Module.imports" href="#wasmtime.Module.imports">imports</a></code></li>
<li><code><a title="wasmtime.Module.serialize" href="#wasmtime.Module.serialize">serialize</a></code></li>
<li><code><a title="wasmtime.Module.validate" href="#wasmtime.Module.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Store" href="#wasmtime.Store">Store</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.Store.add_fuel" href="#wasmtime.Store.add_fuel">add_fuel</a></code></li>
<li><code><a title="wasmtime.Store.consume_fuel" href="#wasmtime.Store.consume_fuel">consume_fuel</a></code></li>
<li><code><a title="wasmtime.Store.data" href="#wasmtime.Store.data">data</a></code></li>
<li><code><a title="wasmtime.Store.fuel_consumed" href="#wasmtime.Store.fuel_consumed">fuel_consumed</a></code></li>
<li><code><a title="wasmtime.Store.gc" href="#wasmtime.Store.gc">gc</a></code></li>
<li><code><a title="wasmtime.Store.set_epoch_deadline" href="#wasmtime.Store.set_epoch_deadline">set_epoch_deadline</a></code></li>
<li><code><a title="wasmtime.Store.set_limits" href="#wasmtime.Store.set_limits">set_limits</a></code></li>
<li><code><a title="wasmtime.Store.set_wasi" href="#wasmtime.Store.set_wasi">set_wasi</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Table" href="#wasmtime.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Table.get" href="#wasmtime.Table.get">get</a></code></li>
<li><code><a title="wasmtime.Table.grow" href="#wasmtime.Table.grow">grow</a></code></li>
<li><code><a title="wasmtime.Table.set" href="#wasmtime.Table.set">set</a></code></li>
<li><code><a title="wasmtime.Table.size" href="#wasmtime.Table.size">size</a></code></li>
<li><code><a title="wasmtime.Table.type" href="#wasmtime.Table.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.TableType" href="#wasmtime.TableType">TableType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.TableType.element" href="#wasmtime.TableType.element">element</a></code></li>
<li><code><a title="wasmtime.TableType.limits" href="#wasmtime.TableType.limits">limits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Trap" href="#wasmtime.Trap">Trap</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Trap.frames" href="#wasmtime.Trap.frames">frames</a></code></li>
<li><code><a title="wasmtime.Trap.message" href="#wasmtime.Trap.message">message</a></code></li>
<li><code><a title="wasmtime.Trap.trap_code" href="#wasmtime.Trap.trap_code">trap_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.TrapCode" href="#wasmtime.TrapCode">TrapCode</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.TrapCode.BAD_CONVERSION_TO_INTEGER" href="#wasmtime.TrapCode.BAD_CONVERSION_TO_INTEGER">BAD_CONVERSION_TO_INTEGER</a></code></li>
<li><code><a title="wasmtime.TrapCode.BAD_SIGNATURE" href="#wasmtime.TrapCode.BAD_SIGNATURE">BAD_SIGNATURE</a></code></li>
<li><code><a title="wasmtime.TrapCode.HEAP_MISALIGNED" href="#wasmtime.TrapCode.HEAP_MISALIGNED">HEAP_MISALIGNED</a></code></li>
<li><code><a title="wasmtime.TrapCode.INDIRECT_CALL_TO_NULL" href="#wasmtime.TrapCode.INDIRECT_CALL_TO_NULL">INDIRECT_CALL_TO_NULL</a></code></li>
<li><code><a title="wasmtime.TrapCode.INTEGER_DIVISION_BY_ZERO" href="#wasmtime.TrapCode.INTEGER_DIVISION_BY_ZERO">INTEGER_DIVISION_BY_ZERO</a></code></li>
<li><code><a title="wasmtime.TrapCode.INTEGER_OVERFLOW" href="#wasmtime.TrapCode.INTEGER_OVERFLOW">INTEGER_OVERFLOW</a></code></li>
<li><code><a title="wasmtime.TrapCode.INTERRUPT" href="#wasmtime.TrapCode.INTERRUPT">INTERRUPT</a></code></li>
<li><code><a title="wasmtime.TrapCode.MEMORY_OUT_OF_BOUNDS" href="#wasmtime.TrapCode.MEMORY_OUT_OF_BOUNDS">MEMORY_OUT_OF_BOUNDS</a></code></li>
<li><code><a title="wasmtime.TrapCode.STACK_OVERFLOW" href="#wasmtime.TrapCode.STACK_OVERFLOW">STACK_OVERFLOW</a></code></li>
<li><code><a title="wasmtime.TrapCode.TABLE_OUT_OF_BOUNDS" href="#wasmtime.TrapCode.TABLE_OUT_OF_BOUNDS">TABLE_OUT_OF_BOUNDS</a></code></li>
<li><code><a title="wasmtime.TrapCode.UNREACHABLE" href="#wasmtime.TrapCode.UNREACHABLE">UNREACHABLE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Val" href="#wasmtime.Val">Val</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.Val.as_externref" href="#wasmtime.Val.as_externref">as_externref</a></code></li>
<li><code><a title="wasmtime.Val.as_f32" href="#wasmtime.Val.as_f32">as_f32</a></code></li>
<li><code><a title="wasmtime.Val.as_f64" href="#wasmtime.Val.as_f64">as_f64</a></code></li>
<li><code><a title="wasmtime.Val.as_funcref" href="#wasmtime.Val.as_funcref">as_funcref</a></code></li>
<li><code><a title="wasmtime.Val.as_i32" href="#wasmtime.Val.as_i32">as_i32</a></code></li>
<li><code><a title="wasmtime.Val.as_i64" href="#wasmtime.Val.as_i64">as_i64</a></code></li>
<li><code><a title="wasmtime.Val.externref" href="#wasmtime.Val.externref">externref</a></code></li>
<li><code><a title="wasmtime.Val.f32" href="#wasmtime.Val.f32">f32</a></code></li>
<li><code><a title="wasmtime.Val.f64" href="#wasmtime.Val.f64">f64</a></code></li>
<li><code><a title="wasmtime.Val.funcref" href="#wasmtime.Val.funcref">funcref</a></code></li>
<li><code><a title="wasmtime.Val.i32" href="#wasmtime.Val.i32">i32</a></code></li>
<li><code><a title="wasmtime.Val.i64" href="#wasmtime.Val.i64">i64</a></code></li>
<li><code><a title="wasmtime.Val.ref_null" href="#wasmtime.Val.ref_null">ref_null</a></code></li>
<li><code><a title="wasmtime.Val.type" href="#wasmtime.Val.type">type</a></code></li>
<li><code><a title="wasmtime.Val.value" href="#wasmtime.Val.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.ValType" href="#wasmtime.ValType">ValType</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.ValType.externref" href="#wasmtime.ValType.externref">externref</a></code></li>
<li><code><a title="wasmtime.ValType.f32" href="#wasmtime.ValType.f32">f32</a></code></li>
<li><code><a title="wasmtime.ValType.f64" href="#wasmtime.ValType.f64">f64</a></code></li>
<li><code><a title="wasmtime.ValType.funcref" href="#wasmtime.ValType.funcref">funcref</a></code></li>
<li><code><a title="wasmtime.ValType.i32" href="#wasmtime.ValType.i32">i32</a></code></li>
<li><code><a title="wasmtime.ValType.i64" href="#wasmtime.ValType.i64">i64</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.WasiConfig" href="#wasmtime.WasiConfig">WasiConfig</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.WasiConfig.argv" href="#wasmtime.WasiConfig.argv">argv</a></code></li>
<li><code><a title="wasmtime.WasiConfig.env" href="#wasmtime.WasiConfig.env">env</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_argv" href="#wasmtime.WasiConfig.inherit_argv">inherit_argv</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_env" href="#wasmtime.WasiConfig.inherit_env">inherit_env</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_stderr" href="#wasmtime.WasiConfig.inherit_stderr">inherit_stderr</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_stdin" href="#wasmtime.WasiConfig.inherit_stdin">inherit_stdin</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_stdout" href="#wasmtime.WasiConfig.inherit_stdout">inherit_stdout</a></code></li>
<li><code><a title="wasmtime.WasiConfig.preopen_dir" href="#wasmtime.WasiConfig.preopen_dir">preopen_dir</a></code></li>
<li><code><a title="wasmtime.WasiConfig.stderr_file" href="#wasmtime.WasiConfig.stderr_file">stderr_file</a></code></li>
<li><code><a title="wasmtime.WasiConfig.stdin_file" href="#wasmtime.WasiConfig.stdin_file">stdin_file</a></code></li>
<li><code><a title="wasmtime.WasiConfig.stdout_file" href="#wasmtime.WasiConfig.stdout_file">stdout_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>